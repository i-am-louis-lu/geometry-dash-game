<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash Clone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Orbitron', sans-serif;
        }

        #gameContainer {
            position: relative;
        }

        canvas {
            display: block;
            border: 3px solid #00d4ff;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            background: linear-gradient(180deg, #ffffff 0%, #888888 50%, #333333 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
        }

        #gems {
            background: linear-gradient(180deg, #4466aa 0%, #223366 50%, #112244 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(2px 2px 4px rgba(0, 50, 150, 0.5));
        }

        #gameOver,
        #startScreen,
        #winScreen,
        #skinShop,
        #homePage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 8px;
        }

        #gameOver,
        #winScreen,
        #skinShop,
        #startScreen {
            display: none;
        }

        #homePage {
            flex-direction: row !important;
            justify-content: space-around !important;
            padding: 20px;
        }

        .home-left {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }

        .home-right {
            flex: 1;
            max-width: 350px;
            margin-left: 20px;
        }

        #homeLeaderboard {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        #homeLeaderboard h3 {
            color: #ffd700;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
        }

        #home-leaderboard-entries {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #homePlayerPreview {
            width: 80px;
            height: 80px;
            margin: 15px auto;
            border-radius: 8px;
            box-shadow: 0 0 20px currentColor;
        }

        .home-gems {
            font-size: 24px;
            color: #4466aa;
            margin: 10px 0;
        }

        .home-btn {
            margin-top: 10px;
            background: linear-gradient(180deg, #666, #333) !important;
        }

        #adminCode {
            margin-top: 20px;
            padding: 8px 12px;
            border: 1px solid #333;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: #666;
            font-size: 12px;
            width: 150px;
            text-align: center;
        }

        #adminCode:focus {
            outline: none;
            border-color: #4466aa;
        }

        .skin-btn {
            margin-top: 10px;
            background: linear-gradient(180deg, #4466aa, #223366) !important;
        }

        #skinGrid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px;
            max-width: 600px;
        }

        .skin-card {
            background: rgba(30, 30, 50, 0.9);
            border: 2px solid #444;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .skin-card:hover {
            border-color: #00d4ff;
            transform: scale(1.05);
        }

        .skin-card.selected {
            border-color: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }

        .skin-card.locked {
            opacity: 0.6;
        }

        .skin-preview {
            width: 50px;
            height: 50px;
            margin: 0 auto 10px;
            border-radius: 5px;
        }

        .skin-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .skin-cost {
            font-size: 12px;
            color: #4466aa;
        }

        .skin-owned {
            color: #00ff00;
            font-size: 12px;
        }

        #totalGems {
            color: #4466aa;
            font-size: 20px;
            margin-bottom: 10px;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(180deg, #ffffff 0%, #00d4ff 30%, #0088aa 70%, #004466 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 20px #00d4ff);
        }

        h2 {
            font-size: 36px;
            margin-bottom: 10px;
            background: linear-gradient(180deg, #ffffff 0%, #ff6b6b 40%, #cc4444 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .win-title {
            background: linear-gradient(180deg, #ffffff 0%, #00ff88 30%, #00cc66 70%, #006633 100%) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            background-clip: text !important;
            filter: drop-shadow(0 0 20px #00ff88) !important;
        }

        p {
            font-size: 20px;
            margin-bottom: 30px;
            background: linear-gradient(180deg, #ffffff 0%, #cccccc 50%, #888888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .btn {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            border: none;
            border-radius: 30px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 10px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        #instructions {
            font-size: 16px;
            color: #888;
            margin-top: 20px;
        }

        #gamertag-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-radius: 8px;
            z-index: 100;
        }

        #gamertag-input {
            padding: 12px 20px;
            font-size: 20px;
            border: 2px solid #00d4ff;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            text-align: center;
            margin: 15px 0;
            width: 250px;
        }

        #gamertag-input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
        }

        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00d4ff;
            min-width: 220px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 50;
        }

        #leaderboard h3 {
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
            background: linear-gradient(180deg, #ffffff 0%, #00d4ff 50%, #0066aa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: #fff;
        }

        .leaderboard-entry.current-player {
            color: #00ff88;
            font-weight: bold;
        }

        .leaderboard-rank {
            color: #ffcc00;
            width: 25px;
        }

        .leaderboard-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .leaderboard-score {
            color: #00d4ff;
            margin-left: 10px;
        }

        .leaderboard-round {
            color: #888;
            margin-left: 5px;
            font-size: 10px;
        }

        .leaderboard-loading {
            color: #888;
            text-align: center;
            font-size: 12px;
        }
    </style>
</head>

<body>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="500"></canvas>
        <div id="ui">
            <div id="round">Round: 1/5</div>
            <div id="score">Score: 0</div>
            <div id="attempts">Attempts: 1</div>
            <div id="gems">Gems: 0</div>
        </div>
        <div id="homePage">
            <div class="home-left">
                <h1>GEOMETRY DASH</h1>
                <div id="homePlayerPreview"></div>
                <p id="homeGems" class="home-gems">üíé 0</p>
                <button class="btn" onclick="startFromHome()">PLAY</button>
                <button class="btn skin-btn" onclick="openSkinShopFromHome()">SKINS</button>
                <div id="instructions">
                    Press SPACE, UP ARROW, or CLICK to jump<br>
                    Land on green platforms for shortcuts!
                </div>
                <input type="text" id="adminCode" placeholder="Enter code..." maxlength="20" onkeypress="checkAdminCode(event)">
            </div>
            <div class="home-right">
                <div id="homeLeaderboard">
                    <h3>üèÜ GLOBAL LEADERBOARD</h3>
                    <div id="home-leaderboard-entries">
                        <div class="leaderboard-loading">Loading...</div>
                    </div>
                </div>
            </div>
        </div>
        <div id="startScreen" style="display: none;">
            <h1>GEOMETRY DASH</h1>
            <p>Reach the finish line to win!</p>
            <button class="btn" onclick="startGame()">PLAY</button>
            <button class="btn skin-btn" onclick="openSkinShop()">SKINS</button>
            <div id="instructions">
                Press SPACE, UP ARROW, or CLICK to jump<br>
                Land on green platforms for shortcuts!
            </div>
        </div>
        <div id="skinShop">
            <h2>SKIN SHOP</h2>
            <p id="totalGems">Total Gems: 0</p>
            <div id="skinGrid"></div>
            <button class="btn" onclick="closeSkinShop()">BACK</button>
        </div>
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <p id="finalScore">Progress: 0%</p>
            <p id="highScore">Best: 0%</p>
            <button class="btn" onclick="restartGame()">RETRY</button>
            <button class="btn home-btn" onclick="goToHome()">HOME</button>
        </div>
        <div id="winScreen">
            <h2 class="win-title">LEVEL COMPLETE!</h2>
            <p id="winScore">Score: 0</p>
            <p id="winAttempts">Attempts: 1</p>
            <button class="btn" onclick="nextRound()">NEXT ROUND</button>
            <button class="btn home-btn" onclick="goToHome()">HOME</button>
        </div>
        <div id="gamertag-screen">
            <h1>GEOMETRY DASH</h1>
            <p>Enter your gamertag to compete!</p>
            <input type="text" id="gamertag-input" placeholder="Your Gamertag" maxlength="15">
            <button class="btn" onclick="submitGamertag()">START GAME</button>
        </div>
        <div id="leaderboard">
            <h3>GLOBAL LEADERBOARD</h3>
            <div id="leaderboard-entries">
                <div class="leaderboard-loading">Loading...</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Helper function to draw gradient text (white to black gradient, or custom colors)
        function drawGradientText(text, x, y, font, align = 'center', colorTop = '#ffffff', colorMid = '#aaaaaa', colorBottom = '#444444') {
            ctx.save();
            ctx.font = font;
            ctx.textAlign = align;

            // Extract font size from font string (e.g., "bold 18px Orbitron" -> 18)
            const fontSizeMatch = font.match(/(\d+)px/);
            const textHeight = fontSizeMatch ? parseInt(fontSizeMatch[1]) : 16;

            // Create vertical gradient
            const gradient = ctx.createLinearGradient(0, y - textHeight * 0.8, 0, y + textHeight * 0.2);
            gradient.addColorStop(0, colorTop);
            gradient.addColorStop(0.5, colorMid);
            gradient.addColorStop(1, colorBottom);

            ctx.fillStyle = gradient;
            ctx.fillText(text, x, y);
            ctx.restore();
        }

        const scoreDisplay = document.getElementById('score');
        const attemptsDisplay = document.getElementById('attempts');
        const roundDisplay = document.getElementById('round');
        const gameOverScreen = document.getElementById('gameOver');
        const startScreen = document.getElementById('startScreen');
        const winScreen = document.getElementById('winScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScore');
        const winScoreDisplay = document.getElementById('winScore');
        const winAttemptsDisplay = document.getElementById('winAttempts');
        const gamertagScreen = document.getElementById('gamertag-screen');
        const gamertagInput = document.getElementById('gamertag-input');
        const leaderboardEl = document.getElementById('leaderboard');
        const leaderboardEntries = document.getElementById('leaderboard-entries');
        // Web Audio API for generated music
        let audioCtx = null;
        let musicPlaying = false;
        let musicLoopTimeout = null;

        // Background stars - reduced for clarity
        const stars = [];
        const NUM_STARS = 30;
        for (let i = 0; i < NUM_STARS; i++) {
            stars.push({
                x: Math.random() * 900,
                y: Math.random() * 350,
                size: Math.random() * 1.5 + 0.5,
                speed: Math.random() * 0.3 + 0.1,
                brightness: Math.random() * 0.3 + 0.2,
                twinkle: Math.random() * Math.PI * 2
            });
        }

        // Music state
        let musicStarted = false;

        // Gamertag and leaderboard state
        let playerGamertag = '';
        let leaderboard = [];
        let totalScore = 0;

        // Global leaderboard using Firebase Realtime Database
        const FIREBASE_DB_URL = 'https://geometry-dash-scores-default-rtdb.firebaseio.com';

        // Fixed seed for consistent maps across all players
        const MAP_SEED = 12345;
        let seedRandom = MAP_SEED;

        function seededRandom() {
            seedRandom = (seedRandom * 9301 + 49297) % 233280;
            return seedRandom / 233280;
        }

        function resetSeed() {
            seedRandom = MAP_SEED;
        }

        // Game constants
        const JUMP_DURATION = 30; // Jump duration
        const JUMP_HEIGHT = 145; // Jump height
        const GAME_SPEED_INITIAL = 6;   // Normal game speed
        const GAME_SPEED_MAX = 10;       // Normal max speed
        const GROUND_HEIGHT = 80;

        // Jump state
        let jumpProgress = 0;
        let jumpStartY = 0;

        // Game state
        let gameRunning = false;
        let gameSpeed = GAME_SPEED_INITIAL;
        let score = 0;
        let bestProgress = 0;
        let attempts = 1;
        let groundOffset = 0;
        let bgOffset = 0;
        let levelComplete = false;
        let distanceTraveled = 0;

        // Camera offset for smooth follow
        let cameraX = 0;
        const PLAYER_BASE_X = 100; // Where player normally sits on screen

        // Frame timing - lock to 60fps for consistent speed
        let lastFrameTime = 0;
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS;

        // Round/Level system
        let currentRound = 1;
        const MAX_ROUND = 5;

        // Player
        const player = {
            x: 100,
            y: canvas.height - GROUND_HEIGHT - 40,
            width: 40,
            height: 40,
            velocityY: 0,
            rotation: 0,
            isJumping: false,
            onGround: true,
            onPlatform: false,
            color: '#00d4ff',
            visible: true
        };

        // Obstacles, platforms, pits and finish line
        let obstacles = [];
        let platforms = [];
        let pits = []; // Gaps in the ground - must use platforms to cross
        let finishLine = null;

        // Portals for ship mode
        let portals = [];

        // Ship mode state
        let shipMode = false;
        let shipVelocityY = 0;
        const SHIP_GRAVITY = 0.3;   // Slower fall
        const SHIP_LIFT = -0.8;     // Smaller lift per click
        let lastClickTime = 0;      // Track time of last click for boost calculation
        let wasJumpPressed = false; // Track previous frame's jump state

        // Wormhole transition state
        let wormholeTransition = false;
        let wormholeProgress = 0;
        let wormholeEntering = true; // true = entering ship mode, false = exiting
        const WORMHOLE_DURATION = 150; // frames for transition (2.5 seconds)
        let wormholePlayerY = 0; // Player's Y position in the wormhole scene
        let wormholeWaitingForClick = false; // Wait for click after cutscene

        // Spawn countdown - gives player time to get ready after wormhole
        let spawnCountdown = 0; // frames remaining in countdown (180 = 3 seconds at 60fps)
        let spawnCountdownActive = false;

        // Secret area state
        let secretPortals = []; // Hidden portals to secret areas
        let secretAreaActive = false; // Currently in secret area cutscene
        let secretAreaProgress = 0; // Animation progress
        let secretAreaFound = false; // Has player found the secret this run
        let gems = 0; // Gems collected from secret areas
        let secretEntryX = 0; // X position where player entered secret portal
        let totalGemsEver = 0; // Total gems collected across all games (for unlocks)

        // Player skins system
        const playerSkins = [
            { id: 'default', name: 'Classic', bodyColor1: '#ffcc00', bodyColor2: '#e67300', eyeColor: '#00d4ff', cost: 0 },
            { id: 'ice', name: 'Ice Cube', bodyColor1: '#66ffff', bodyColor2: '#0088aa', eyeColor: '#ffffff', cost: 5 },
            { id: 'fire', name: 'Fire', bodyColor1: '#ff4400', bodyColor2: '#880000', eyeColor: '#ffff00', cost: 10 },
            { id: 'neon', name: 'Neon', bodyColor1: '#ff00ff', bodyColor2: '#8800aa', eyeColor: '#00ff00', cost: 15 },
            { id: 'gold', name: 'Golden', bodyColor1: '#ffd700', bodyColor2: '#b8860b', eyeColor: '#ffffff', cost: 20 },
            { id: 'shadow', name: 'Shadow', bodyColor1: '#333333', bodyColor2: '#111111', eyeColor: '#ff0000', cost: 25 },
            { id: 'rainbow', name: 'Rainbow', bodyColor1: '#ff0000', bodyColor2: '#0000ff', eyeColor: '#00ff00', cost: 30 }
        ];
        let currentSkin = 'default';
        let unlockedSkins = ['default']; // Start with default unlocked

        // Ship trail for showing click pattern
        let shipTrail = [];

        // Tunnel walls for ship mode (top and bottom spikes)
        let tunnelWalls = [];

        // Jump orbs - give boosted jump when touched and player presses jump
        let orbs = [];
        let canOrbJump = false; // True when player is touching an orb
        let currentOrb = null; // The orb player is touching
        const ORB_JUMP_FORCE = -24; // Super high jump

        // Obstacle types categorized by difficulty with their widths
        const obstacleWidths = {
            'spike': 50,
            'doubleSpike': 100,
            'tripleSpike': 150,
            'quadSpike': 200,
            'block': 50,
            'doubleBlock': 90,
            'tallBlock': 50,
            'stepsUp': 400,
            'stepsDown': 400,
            'stepsUpDown': 700,
            'stepsWithSpikes': 400,
            'boxWithSpike': 80,
            'tallBoxWithSpike': 70,
            'platformOverPit': 200,
            'stairPlatformsOverPit': 280,
            'platformHopOverPit': 350,
            'longPitWithPlatforms': 420,
            'sawBlade': 60,
            'movingSpikes': 180,
            'spikeWall': 100,
            'fakePlatform': 200,
            'spikeTunnel': 250,
            'disappearingPlatform': 200,
        };

        // Very easy obstacles for the start
        const veryEasyObstacles = ['spike', 'block'];
        const easyObstacles = ['spike', 'doubleSpike', 'block', 'tallBlock'];
        const mediumObstacles = ['tripleSpike', 'doubleBlock', 'stepsUp', 'stepsDown', 'boxWithSpike', 'platformOverPit', 'sawBlade'];
        const hardObstacles = ['quadSpike', 'stepsUpDown', 'stepsWithSpikes', 'tallBoxWithSpike', 'stairPlatformsOverPit', 'platformHopOverPit', 'spikeWall', 'disappearingPlatform'];
        const veryHardObstacles = ['longPitWithPlatforms', 'movingSpikes', 'spikeTunnel'];

        // Staircase types that already have spikes built in - don't add spikes after these
        const staircaseTypes = ['stepsUp', 'stepsDown', 'stepsUpDown', 'stepsWithSpikes'];

        // Wide obstacles that need extra spacing
        const wideObstacles = ['stepsUp', 'stepsDown', 'stepsUpDown', 'stepsWithSpikes', 'platformHopOverPit', 'longPitWithPlatforms', 'spikeTunnel', 'movingSpikes'];

        // Obstacles that have platforms/pits - don't add spikes near these either
        const platformObstacles = ['platformOverPit', 'stairPlatformsOverPit', 'platformHopOverPit', 'longPitWithPlatforms'];

        // Generate random level with gradual difficulty ramp
        function generateRandomLevel() {
            const tempPatterns = [];
            const totalPatterns = 30;

            // First pass: generate the main obstacles with VERY gradual difficulty increase
            for (let i = 0; i < totalPatterns; i++) {
                const progress = i / totalPatterns;
                let obstacleType;

                // Very gradual difficulty ramp (using seededRandom for consistent maps)
                if (progress < 0.15) {
                    obstacleType = veryEasyObstacles[Math.floor(seededRandom() * veryEasyObstacles.length)];
                } else if (progress < 0.3) {
                    obstacleType = easyObstacles[Math.floor(seededRandom() * easyObstacles.length)];
                } else if (progress < 0.5) {
                    if (seededRandom() < 0.6) {
                        obstacleType = easyObstacles[Math.floor(seededRandom() * easyObstacles.length)];
                    } else {
                        obstacleType = mediumObstacles[Math.floor(seededRandom() * mediumObstacles.length)];
                    }
                } else if (progress < 0.7) {
                    const roll = seededRandom();
                    if (roll < 0.3) {
                        obstacleType = easyObstacles[Math.floor(seededRandom() * easyObstacles.length)];
                    } else if (roll < 0.85) {
                        obstacleType = mediumObstacles[Math.floor(seededRandom() * mediumObstacles.length)];
                    } else {
                        obstacleType = hardObstacles[Math.floor(seededRandom() * hardObstacles.length)];
                    }
                } else if (progress < 0.85) {
                    if (seededRandom() < 0.4) {
                        obstacleType = mediumObstacles[Math.floor(seededRandom() * mediumObstacles.length)];
                    } else {
                        obstacleType = hardObstacles[Math.floor(seededRandom() * hardObstacles.length)];
                    }
                } else {
                    if (seededRandom() < 0.5) {
                        obstacleType = hardObstacles[Math.floor(seededRandom() * hardObstacles.length)];
                    } else {
                        obstacleType = veryHardObstacles[Math.floor(seededRandom() * veryHardObstacles.length)];
                    }
                }

                tempPatterns.push(obstacleType);
            }

            // Second pass: add spikes between obstacles
            const patterns = [];
            for (let i = 0; i < tempPatterns.length; i++) {
                const currentType = tempPatterns[i];
                const nextType = tempPatterns[i + 1];
                const progress = i / tempPatterns.length;

                patterns.push({ type: currentType });

                const currentIsStaircase = staircaseTypes.includes(currentType);
                const nextIsStaircase = nextType && staircaseTypes.includes(nextType);
                const currentIsPlatform = platformObstacles.includes(currentType);
                const nextIsPlatform = nextType && platformObstacles.includes(nextType);
                const currentIsWide = wideObstacles.includes(currentType);
                const nextIsWide = nextType && wideObstacles.includes(nextType);

                const canAddSpikes = !currentIsStaircase && !nextIsStaircase &&
                    !currentIsPlatform && !nextIsPlatform &&
                    !currentIsWide && !nextIsWide;

                const spikeChance = progress < 0.3 ? 0 : (progress - 0.3) * 0.7;

                if (canAddSpikes && seededRandom() < spikeChance && i < tempPatterns.length - 1) {
                    if (progress < 0.5) {
                        patterns.push({ type: 'spike' });
                    } else {
                        patterns.push({ type: 'doubleSpike' });
                    }
                }
            }

            return patterns;
        }

        let levelPatterns = generateRandomLevel();

        // Admin fly mode
        let flyMode = false;
        const ADMIN_CODE = 'flytest123';
        let invincible = false;
        let invincibleTimer = 0;
        const INVINCIBLE_DURATION = 600; // 10 seconds at 60fps

        // Particles
        let particles = [];

        // Input
        let jumpPressed = false;
        let adminCodeBuffer = '';

        // Event listeners
        document.addEventListener('keydown', (e) => {
            // Track typed characters for admin code
            if (e.key.length === 1) {
                adminCodeBuffer += e.key.toLowerCase();
                // Keep only last 15 characters
                if (adminCodeBuffer.length > 15) {
                    adminCodeBuffer = adminCodeBuffer.slice(-15);
                }
                // Check if admin code was typed
                if (adminCodeBuffer.includes(ADMIN_CODE)) {
                    flyMode = !flyMode;
                    adminCodeBuffer = '';
                    console.log('Fly mode:', flyMode ? 'ON' : 'OFF');
                    // When turning off fly mode, start slow drop with invincibility
                    if (!flyMode) {
                        player.velocityY = 2; // Start slow descent
                        player.onGround = false;
                        player.isJumping = false;
                        invincible = true;
                        invincibleTimer = INVINCIBLE_DURATION;
                        console.log('Invincibility: 60 seconds');
                    }
                }
            }

            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                jumpPressed = true;
                if (!flyMode && !shipMode && gameRunning) {
                    if (canOrbJump && currentOrb) {
                        orbJump();
                    } else if (player.onGround || player.onPlatform) {
                        jump();
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                jumpPressed = false;
            }
        });

        canvas.addEventListener('mousedown', () => {
            jumpPressed = true;
            if (!shipMode && gameRunning) {
                if (canOrbJump && currentOrb) {
                    orbJump();
                } else if (player.onGround || player.onPlatform) {
                    jump();
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            jumpPressed = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            jumpPressed = true;
            if (!shipMode && gameRunning) {
                if (canOrbJump && currentOrb) {
                    orbJump();
                } else if (player.onGround || player.onPlatform) {
                    jump();
                }
            }
        });

        canvas.addEventListener('touchend', () => {
            jumpPressed = false;
        });

        function jump() {
            if (player.onGround || player.onPlatform) {
                // Natural arc jump with smooth easing
                jumpProgress = 0;
                jumpStartY = player.y;
                player.onGround = false;
                player.onPlatform = false;
                player.isJumping = true;
                createJumpParticles();
            }
        }

        function orbJump() {
            // Boosted jump from orb - goes super high, minimal forward scaling
            // Only slight speed scaling so it doesn't travel too far forward
            const speedRatio = gameSpeed / GAME_SPEED_INITIAL;
            player.velocityY = ORB_JUMP_FORCE * (1 + (speedRatio - 1) * 0.2);
            player.onGround = false;
            player.onPlatform = false;
            player.isJumping = true;

            // Mark orb as used
            if (currentOrb) {
                currentOrb.used = true;
                createOrbParticles(currentOrb);
            }

            canOrbJump = false;
            currentOrb = null;
        }

        function createJumpParticles() {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height,
                    vx: (Math.random() - 0.5) * 4,
                    vy: Math.random() * -2,
                    life: 30,
                    color: player.color
                });
            }
        }

        function createOrbParticles(orb) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: orb.x + orb.width / 2,
                    y: orb.y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 25,
                    color: '#ffffff'
                });
            }
        }

        function createDeathParticles() {
            // Yellow cube explosion effect
            const centerX = player.x + player.width / 2;
            const centerY = player.y + player.height / 2;

            // Create yellow cube particles radiating outward (shorter distance)
            for (let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 2;
                const speed = 2 + Math.random() * 4;  // Shorter distance
                particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 25 + Math.random() * 20,
                    color: '#ffcc00',
                    isSquare: true,
                    size: 3 + Math.random() * 4
                });
            }
        }

        // Spawn wave rings
        let spawnWaves = [];

        function createSpawnWaves() {
            const centerX = player.x + player.width / 2;
            const centerY = player.y + player.height / 2;

            // Create 3 waves that expand outward
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    spawnWaves.push({
                        x: centerX,
                        y: centerY,
                        radius: 5,         // Start closer to player
                        maxRadius: 200,    // Travel much farther
                        life: 40           // Last longer for the distance
                    });
                }, i * 200);  // Further apart in time
            }
        }

        function createWinParticles() {
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 1) * 10,
                    life: 90,
                    color: ['#00ff88', '#00d4ff', '#ffff00', '#ff00ff'][Math.floor(Math.random() * 4)]
                });
            }
        }

        function createPortalParticles(portal) {
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: portal.x + portal.width / 2,
                    y: portal.y + Math.random() * portal.height,
                    vx: (Math.random() - 0.3) * 8,
                    vy: (Math.random() - 0.5) * 6,
                    life: 40,
                    color: portal.type === 'shipEnter' ? '#ff00ff' : '#00ff88'
                });
            }
        }

        function checkTunnelCollision(player, wall) {
            const padding = 6;
            const px = player.x + padding;
            const py = player.y + padding;
            const pw = player.width - padding * 2;
            const ph = player.height - padding * 2;

            // Check if wall is on screen
            if (wall.x > canvas.width || wall.x + wall.width < 0) {
                return false;
            }

            if (wall.type === 'tunnelTop') {
                // Top wall with spikes pointing down - check if player hits the spike tips
                if (px < wall.x + wall.width && px + pw > wall.x) {
                    if (py < wall.y + wall.height) {
                        return true;
                    }
                }
            } else if (wall.type === 'tunnelBottom') {
                // Bottom wall with spikes pointing up
                if (px < wall.x + wall.width && px + pw > wall.x) {
                    if (py + ph > wall.y) {
                        return true;
                    }
                }
            }

            return false;
        }

        function generateLevel() {
            obstacles = [];
            platforms = [];
            pits = [];
            portals = [];
            tunnelWalls = [];
            orbs = [];
            secretPortals = [];
            finishLine = null;

            const BASE_GAP = 200; // Base gap between obstacles
            let currentX = canvas.width + 400; // Start position

            // Track obstacle positions for orb placement
            let lastObstacleEnd = currentX;

            // Obstacle types that benefit from orbs (hard to pass without boost)
            const hardObstacleTypes = ['tripleSpike', 'quadSpike', 'tallBlock', 'spikeTunnel', 'spikeWall', 'movingSpikes'];

            // Orb frequency based on round
            // Round 1: No orbs
            // Round 2: Occasional orbs (30%)
            // Round 3+: More orbs (50-70%)
            const orbChance = currentRound === 1 ? 0 : (currentRound === 2 ? 0.3 : 0.5 + (currentRound - 3) * 0.1);

            // Generate first section (cube mode)
            const firstSectionPatterns = Math.floor(levelPatterns.length * 0.4);
            for (let i = 0; i < firstSectionPatterns; i++) {
                const pattern = levelPatterns[i];
                const patternWidth = obstacleWidths[pattern.type] || 100;

                // Add orb before hard obstacles, or when gap is tight (only in round 2+)
                const gapToNext = currentX - lastObstacleEnd;
                const isHardObstacle = hardObstacleTypes.includes(pattern.type);
                const needsOrb = currentRound >= 2 && ((gapToNext > 60 && gapToNext < 250 && i > 0) || (isHardObstacle && i > 0));

                if (needsOrb && Math.random() < orbChance) {
                    // Add an orb before this obstacle
                    const orbX = currentX - 60;
                    orbs.push({
                        x: orbX,
                        y: canvas.height - GROUND_HEIGHT - 50,
                        width: 20,
                        height: 50,
                        used: false
                    });
                }

                createPattern(pattern.type, currentX);
                lastObstacleEnd = currentX + patternWidth;

                let extraSpace = 0;
                if (staircaseTypes.includes(pattern.type)) {
                    extraSpace = 200;
                } else if (wideObstacles.includes(pattern.type)) {
                    extraSpace = 150;
                }
                currentX += patternWidth + BASE_GAP + extraSpace;
            }

            // Add SECRET PORTAL - spawns at random location in rounds 2-5
            // Only appears if hasn't been found this run
            if (currentRound >= 2 && !secretAreaFound) {
                // Random position somewhere in the middle of the level
                const minX = canvas.width + 800;
                const maxX = currentX - 500;
                const secretX = minX + seededRandom() * (maxX - minX);

                // Random height - either ground level or elevated
                const heightOptions = [
                    canvas.height - GROUND_HEIGHT - 80,  // Ground level (easy to reach)
                    canvas.height - GROUND_HEIGHT - 150, // Medium height
                    canvas.height - GROUND_HEIGHT - 200  // High up (needs platform)
                ];
                const secretY = heightOptions[Math.floor(seededRandom() * heightOptions.length)];

                // Add a small platform hint if portal is high up
                if (secretY < canvas.height - GROUND_HEIGHT - 120) {
                    platforms.push({
                        x: secretX - 80,
                        y: secretY + 50,
                        width: 60,
                        height: 15
                    });
                }

                // The secret portal
                secretPortals.push({
                    x: secretX,
                    y: secretY,
                    width: 40,
                    height: 70,
                    shimmer: 0
                });
            }

            // Add portal to enter ship mode
            currentX += 100;
            portals.push({
                x: currentX,
                y: canvas.height - GROUND_HEIGHT - 120,
                width: 40,
                height: 120,
                type: 'shipEnter'
            });
            currentX += 150;

            // Generate ship tunnel section
            const tunnelLength = 2500;
            const tunnelStart = currentX;
            const tunnelEnd = currentX + tunnelLength;

            // Create tunnel with varying spike patterns
            for (let tx = tunnelStart; tx < tunnelEnd; tx += 80) {
                const progress = (tx - tunnelStart) / tunnelLength;

                // Vary the gap size based on progress (gets tighter) - made easier
                const baseGap = 250;
                const minGap = 180;
                const gap = baseGap - (baseGap - minGap) * progress * 0.3;

                // Center of the tunnel varies with a sine wave
                const centerY = canvas.height / 2 + Math.sin((tx - tunnelStart) * 0.008) * 80;

                const topHeight = centerY - gap / 2;
                const bottomY = centerY + gap / 2;
                const bottomHeight = canvas.height - bottomY;

                // Top spikes (pointing down)
                tunnelWalls.push({
                    x: tx,
                    y: 0,
                    width: 80,
                    height: topHeight,
                    type: 'tunnelTop'
                });

                // Bottom spikes (pointing up)
                tunnelWalls.push({
                    x: tx,
                    y: bottomY,
                    width: 80,
                    height: bottomHeight,
                    type: 'tunnelBottom'
                });

            }

            currentX = tunnelEnd + 100;

            // Add portal to exit ship mode
            portals.push({
                x: currentX,
                y: canvas.height - GROUND_HEIGHT - 120,
                width: 40,
                height: 120,
                type: 'shipExit'
            });
            currentX += 200;

            // Reset tracking for second section
            lastObstacleEnd = currentX;

            // Generate remaining section (cube mode again)
            for (let i = firstSectionPatterns; i < levelPatterns.length; i++) {
                const pattern = levelPatterns[i];
                const patternWidth = obstacleWidths[pattern.type] || 100;

                // Add orb before hard obstacles, or when gap is tight (only in round 2+)
                const gapToNext = currentX - lastObstacleEnd;
                const isHardObstacle = hardObstacleTypes.includes(pattern.type);
                const needsOrb = currentRound >= 2 && ((gapToNext > 60 && gapToNext < 250 && i > firstSectionPatterns) || (isHardObstacle && i > firstSectionPatterns));

                if (needsOrb && Math.random() < orbChance) {
                    const orbX = currentX - 60;
                    orbs.push({
                        x: orbX,
                        y: canvas.height - GROUND_HEIGHT - 50,
                        width: 20,
                        height: 50,
                        used: false
                    });
                }

                createPattern(pattern.type, currentX);
                lastObstacleEnd = currentX + patternWidth;

                let extraSpace = 0;
                if (staircaseTypes.includes(pattern.type)) {
                    extraSpace = 200;
                } else if (wideObstacles.includes(pattern.type)) {
                    extraSpace = 150;
                }
                currentX += patternWidth + BASE_GAP + extraSpace;
            }

            // Add finish line after all obstacles
            finishLine = {
                x: currentX + 200,
                width: 60
            };

            // Post-processing: Remove any spikes that overlap with steps
            removeOverlappingSpikes();

            // Post-processing: Clear landing zones after orbs
            clearOrbLandingZones();
        }

        function removeOverlappingSpikes() {
            // Get all step obstacles
            const steps = obstacles.filter(o => o.type === 'step');

            // Remove any spikes that overlap with steps
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                if (obs.type === 'spike' || obs.type === 'spikeDown' || obs.type === 'longSpike') {
                    // Check if this spike overlaps with any step
                    for (const step of steps) {
                        // Check horizontal overlap
                        const horizontalOverlap = obs.x < step.x + step.width + 10 &&
                            obs.x + obs.width > step.x - 10;
                        // Check if spike is at or above the step level (could land on it)
                        const verticalConflict = obs.y + obs.height >= step.y - 20;

                        if (horizontalOverlap && verticalConflict) {
                            // Remove this spike - it conflicts with a step
                            obstacles.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            // Remove any obstacles (steps/blocks) that overlap with pits
            const groundY = canvas.height - GROUND_HEIGHT;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                // Check if obstacle is a step or block that sits on the ground
                if (obs.type === 'step' || obs.type === 'block' || obs.type === 'box') {
                    // Check if obstacle bottom touches ground level
                    if (obs.y + obs.height >= groundY - 5) {
                        // Check if this obstacle overlaps with any pit
                        for (const pit of pits) {
                            const horizontalOverlap = obs.x < pit.x + pit.width &&
                                obs.x + obs.width > pit.x;
                            if (horizontalOverlap) {
                                // Remove this obstacle - it's over a pit
                                obstacles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        }

        function clearOrbLandingZones() {
            // For each orb, calculate the landing zone and remove deadly obstacles there
            // Super jump goes very high and lands roughly 100-180 pixels ahead
            const landingDistance = 150; // How far ahead the player lands after super jump
            const landingZoneWidth = 80; // Width of safe landing zone

            for (const orb of orbs) {
                const landingStart = orb.x + landingDistance;
                const landingEnd = landingStart + landingZoneWidth;

                // Remove ground-level deadly obstacles in landing zone
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obs = obstacles[i];
                    // Only remove deadly ground obstacles (spikes, sawblades)
                    const isDeadly = obs.type === 'spike' || obs.type === 'longSpike' ||
                        obs.type === 'sawBlade' || obs.type === 'block';

                    // Check if obstacle is in landing zone
                    const inLandingZone = obs.x + obs.width > landingStart && obs.x < landingEnd;

                    // Only remove ground-level obstacles (not ceiling stuff)
                    const isGroundLevel = obs.y > canvas.height - GROUND_HEIGHT - 120;

                    if (isDeadly && inLandingZone && isGroundLevel) {
                        obstacles.splice(i, 1);
                    }
                }
            }
        }

        function createPattern(type, baseX) {
            const groundY = canvas.height - GROUND_HEIGHT;

            switch (type) {
                case 'spike':
                    obstacles.push({ x: baseX, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    break;

                case 'doubleSpike':
                    obstacles.push({ x: baseX, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 45, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    break;

                case 'tripleSpike':
                    obstacles.push({ x: baseX, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 45, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 90, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    break;

                case 'quadSpike':
                    for (let i = 0; i < 4; i++) {
                        obstacles.push({ x: baseX + i * 45, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    }
                    break;

                case 'block':
                    obstacles.push({ x: baseX, y: groundY - 40, width: 40, height: 40, type: 'block' });
                    break;

                case 'doubleBlock':
                    obstacles.push({ x: baseX, y: groundY - 40, width: 40, height: 40, type: 'block' });
                    obstacles.push({ x: baseX + 40, y: groundY - 40, width: 40, height: 40, type: 'block' });
                    break;

                case 'tallBlock':
                    obstacles.push({ x: baseX, y: groundY - 80, width: 40, height: 80, type: 'block' });
                    break;

                case 'spikeBlock':
                    obstacles.push({ x: baseX, y: groundY - 40, width: 40, height: 40, type: 'block' });
                    obstacles.push({ x: baseX, y: groundY - 80, width: 40, height: 40, type: 'spike' });
                    break;

                // NEW: Box with spike on top (jumpable platform with danger)
                case 'boxWithSpike':
                    obstacles.push({ x: baseX, y: groundY - 50, width: 60, height: 50, type: 'box' });
                    obstacles.push({ x: baseX + 10, y: groundY - 85, width: 40, height: 35, type: 'spike' });
                    break;

                // NEW: Tall box with spike on top
                case 'tallBoxWithSpike':
                    obstacles.push({ x: baseX, y: groundY - 80, width: 50, height: 80, type: 'box' });
                    obstacles.push({ x: baseX + 5, y: groundY - 115, width: 40, height: 35, type: 'spike' });
                    break;

                // Platform over a pit - MUST use platform or die
                case 'platformOverPit':
                    pits.push({ x: baseX - 20, width: 180 });
                    platforms.push({ x: baseX, y: groundY - 70, width: 140, height: 18 });
                    break;

                // Stair platforms over a pit
                case 'stairPlatformsOverPit':
                    pits.push({ x: baseX - 20, width: 250 });
                    platforms.push({ x: baseX, y: groundY - 50, width: 70, height: 18 });
                    platforms.push({ x: baseX + 110, y: groundY - 100, width: 70, height: 18 });
                    break;

                // Platform hop over pit
                case 'platformHopOverPit':
                    pits.push({ x: baseX - 20, width: 320 });
                    platforms.push({ x: baseX, y: groundY - 60, width: 60, height: 18 });
                    platforms.push({ x: baseX + 100, y: groundY - 90, width: 60, height: 18 });
                    platforms.push({ x: baseX + 200, y: groundY - 60, width: 60, height: 18 });
                    break;

                // Long pit with multiple platforms
                case 'longPitWithPlatforms':
                    pits.push({ x: baseX - 20, width: 400 });
                    platforms.push({ x: baseX, y: groundY - 60, width: 70, height: 18 });
                    platforms.push({ x: baseX + 120, y: groundY - 100, width: 70, height: 18 });
                    platforms.push({ x: baseX + 240, y: groundY - 70, width: 70, height: 18 });
                    break;

                // Steps going up: step -> spike spike -> higher step -> spike spike -> repeat
                case 'stepsUp':
                    // Step 1 (low)
                    obstacles.push({ x: baseX, y: groundY - 30, width: 50, height: 30, type: 'step' });
                    // Two spikes after step 1
                    obstacles.push({ x: baseX + 70, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 115, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 2 (medium)
                    obstacles.push({ x: baseX + 170, y: groundY - 60, width: 50, height: 60, type: 'step' });
                    // Two spikes after step 2
                    obstacles.push({ x: baseX + 240, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 285, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 3 (high)
                    obstacles.push({ x: baseX + 340, y: groundY - 90, width: 50, height: 90, type: 'step' });
                    // Orb on last step (only round 2+)
                    if (currentRound >= 2) {
                        orbs.push({ x: baseX + 355, y: groundY - 90 - 50, width: 20, height: 50, used: false });
                    }
                    break;

                // Steps going down: step -> spike spike -> lower step -> spike spike -> repeat
                case 'stepsDown':
                    // Step 1 (high)
                    obstacles.push({ x: baseX, y: groundY - 90, width: 50, height: 90, type: 'step' });
                    // Two spikes after step 1
                    obstacles.push({ x: baseX + 70, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 115, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 2 (medium)
                    obstacles.push({ x: baseX + 170, y: groundY - 60, width: 50, height: 60, type: 'step' });
                    // Two spikes after step 2
                    obstacles.push({ x: baseX + 240, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 285, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 3 (low)
                    obstacles.push({ x: baseX + 340, y: groundY - 30, width: 50, height: 30, type: 'step' });
                    // Orb on last step (only round 2+)
                    if (currentRound >= 2) {
                        orbs.push({ x: baseX + 355, y: groundY - 30 - 50, width: 20, height: 50, used: false });
                    }
                    break;

                // Steps up then down (pyramid): step -> spikes -> higher step -> spikes -> peak -> spikes -> lower step -> spikes -> step
                case 'stepsUpDown':
                    // Step 1 (low) - going up
                    obstacles.push({ x: baseX, y: groundY - 30, width: 45, height: 30, type: 'step' });
                    // Two spikes
                    obstacles.push({ x: baseX + 60, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 105, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 2 (medium) - going up
                    obstacles.push({ x: baseX + 160, y: groundY - 60, width: 45, height: 60, type: 'step' });
                    // Two spikes
                    obstacles.push({ x: baseX + 220, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 265, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 3 (peak)
                    obstacles.push({ x: baseX + 320, y: groundY - 90, width: 45, height: 90, type: 'step' });
                    // Two spikes
                    obstacles.push({ x: baseX + 380, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 425, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 4 (medium) - going down
                    obstacles.push({ x: baseX + 480, y: groundY - 60, width: 45, height: 60, type: 'step' });
                    // Two spikes
                    obstacles.push({ x: baseX + 540, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 585, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 5 (low) - end
                    obstacles.push({ x: baseX + 640, y: groundY - 30, width: 45, height: 30, type: 'step' });
                    // Orb on last step (only round 2+)
                    if (currentRound >= 2) {
                        orbs.push({ x: baseX + 652, y: groundY - 30 - 50, width: 20, height: 50, used: false });
                    }
                    break;

                // Steps with spikes on top of steps
                case 'stepsWithSpikes':
                    // Step 1 with spike on top
                    obstacles.push({ x: baseX, y: groundY - 35, width: 50, height: 35, type: 'step' });
                    obstacles.push({ x: baseX + 5, y: groundY - 70, width: 40, height: 35, type: 'spike' });
                    // Two ground spikes
                    obstacles.push({ x: baseX + 70, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 115, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 2 with spike on top
                    obstacles.push({ x: baseX + 170, y: groundY - 70, width: 50, height: 70, type: 'step' });
                    obstacles.push({ x: baseX + 175, y: groundY - 105, width: 40, height: 35, type: 'spike' });
                    // Two ground spikes
                    obstacles.push({ x: baseX + 240, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 285, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Step 3
                    obstacles.push({ x: baseX + 340, y: groundY - 35, width: 50, height: 35, type: 'step' });
                    // Orb on last step (only round 2+)
                    if (currentRound >= 2) {
                        orbs.push({ x: baseX + 355, y: groundY - 35 - 50, width: 20, height: 50, used: false });
                    }
                    break;

                // NEW OBSTACLES

                // Tall block - must jump over
                case 'tallBlock':
                    obstacles.push({ x: baseX, y: groundY - 80, width: 40, height: 80, type: 'block' });
                    break;

                // Saw blade - spinning circular danger
                case 'sawBlade':
                    obstacles.push({ x: baseX, y: groundY - 50, width: 50, height: 50, type: 'sawBlade', rotation: 0 });
                    break;

                // Spike wall - tall long spike
                case 'spikeWall':
                    obstacles.push({ x: baseX, y: groundY - 80, width: 40, height: 80, type: 'longSpike' });
                    obstacles.push({ x: baseX + 50, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    break;

                // Moving spikes - row of spikes on alternating blocks
                case 'movingSpikes':
                    obstacles.push({ x: baseX, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Spike on small block
                    obstacles.push({ x: baseX + 50, y: groundY - 20, width: 40, height: 20, type: 'block' });
                    obstacles.push({ x: baseX + 50, y: groundY - 60, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 100, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Spike on small block
                    obstacles.push({ x: baseX + 150, y: groundY - 20, width: 40, height: 20, type: 'block' });
                    obstacles.push({ x: baseX + 150, y: groundY - 60, width: 40, height: 40, type: 'spike' });
                    break;

                // Spike tunnel - must jump through gap between ceiling blocks with spikes
                case 'spikeTunnel':
                    // Ground spikes
                    obstacles.push({ x: baseX, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 45, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    // Ceiling blocks going to roof with spikes hanging down
                    const roofY = 0;
                    const ceilingBlockHeight = canvas.height - GROUND_HEIGHT - 140;
                    obstacles.push({ x: baseX + 90, y: roofY, width: 45, height: ceilingBlockHeight, type: 'ceilingBlock' });
                    obstacles.push({ x: baseX + 90, y: roofY + ceilingBlockHeight, width: 45, height: 40, type: 'spikeDown' });
                    obstacles.push({ x: baseX + 140, y: roofY, width: 45, height: ceilingBlockHeight, type: 'ceilingBlock' });
                    obstacles.push({ x: baseX + 140, y: roofY + ceilingBlockHeight, width: 45, height: 40, type: 'spikeDown' });
                    // More ground spikes
                    obstacles.push({ x: baseX + 190, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    obstacles.push({ x: baseX + 235, y: groundY - 40, width: 40, height: 40, type: 'spike' });
                    break;

                // Disappearing platform over pit - platforms fade in and out
                case 'disappearingPlatform':
                    // Create pit
                    pits.push({ x: baseX, width: 180 });
                    // Add disappearing platforms over the pit
                    platforms.push({
                        x: baseX + 20,
                        y: canvas.height - GROUND_HEIGHT - 60,
                        width: 60,
                        height: 15,
                        disappearing: true,
                        timer: 0,
                        phase: 0 // 0 = visible, 1 = fading, 2 = invisible, 3 = appearing
                    });
                    platforms.push({
                        x: baseX + 100,
                        y: canvas.height - GROUND_HEIGHT - 80,
                        width: 60,
                        height: 15,
                        disappearing: true,
                        timer: 0,
                        phase: 2 // Start invisible, offset timing
                    });
                    break;
            }
        }

        function update() {
            // Always update particles (even when game is not running, for death explosion)
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                particles[i].vy += 0.2;
                particles[i].life--;
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Handle wormhole transition (game is paused during this)
            if (wormholeTransition) {
                // Keep incrementing progress - player/camera keeps moving continuously
                wormholeProgress++;

                // After falling/flying, allow click to continue
                // For entering: 420 frames intro scene + 300 frames falling (5 sec) = 720 total
                // For exiting: 300 frames flying (5 sec)
                const WORMHOLE_FALL_DURATION = wormholeEntering ? 720 : 300;

                if (wormholeProgress >= WORMHOLE_FALL_DURATION && jumpPressed) {
                    // Player clicked after falling, finish transition
                    if (wormholeEntering) {
                        shipMode = true;
                        shipVelocityY = 0;
                        shipTrail = [];
                        player.y = canvas.height / 2 - player.height / 2;
                    } else {
                        shipMode = false;
                        shipTrail = [];
                        player.velocityY = 0;
                        player.y = canvas.height - GROUND_HEIGHT - player.height;
                        player.onGround = true;
                        player.rotation = 0;
                    }
                    wormholeTransition = false;
                    wormholeProgress = 0;
                    // Reset jump state so the click doesn't trigger a jump
                    jumpPressed = false;
                    isJumping = false;
                    jumpProgress = 0;
                    // Start 3 second countdown before game resumes
                    spawnCountdown = 180; // 3 seconds at 60fps
                    spawnCountdownActive = true;
                }
                return; // Pause the game during wormhole
            }

            // Handle secret area cutscene
            if (secretAreaActive) {
                secretAreaProgress++;
                return; // Pause game during secret area
            }

            // Handle spawn countdown after wormhole
            if (spawnCountdownActive) {
                spawnCountdown--;
                if (spawnCountdown <= 0) {
                    spawnCountdownActive = false;
                }
                return; // Don't update game during countdown
            }

            if (!gameRunning) return;

            // Update invincibility timer
            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) {
                    invincible = false;
                    console.log('Invincibility ended');
                }
            }

            // Update distance and speed (exponential increase)
            distanceTraveled += gameSpeed;

            // Fly mode - fast speed for testing, stay near top of screen in aircraft
            if (flyMode) {
                gameSpeed = 10; // Fast constant speed for testing
                const targetY = 60; // Near top but not colliding with wall
                player.y = targetY;
                player.velocityY = 0;
                player.onGround = false;
                player.onPlatform = false;
                player.rotation = 0;

                // Create spark particles from aircraft
                if (Math.random() < 0.4) {
                    particles.push({
                        x: player.x - 10,
                        y: player.y + player.height / 2 + Math.random() * 10,
                        vx: -3 - Math.random() * 3,
                        vy: (Math.random() - 0.5) * 2,
                        life: 20 + Math.random() * 15,
                        color: ['#ffff00', '#ff8800', '#ff4400', '#ffffff'][Math.floor(Math.random() * 4)]
                    });
                }
            } else if (shipMode) {
                // Ship mode physics - Linear Zig-Zag (Wave style)
                const WAVE_SPEED_UP = 9;   // Upward speed
                const WAVE_SPEED_DOWN = 5; // Slower downward speed

                if (jumpPressed) {
                    shipVelocityY = -WAVE_SPEED_UP; // Go up (negative Y)
                } else {
                    shipVelocityY = WAVE_SPEED_DOWN;  // Go down slower (positive Y)
                }

                player.y += shipVelocityY;
                player.onGround = false;
                player.onPlatform = false;

                // Trail Logic: Only add points when direction changes or for the very first point
                const currentPoint = {
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    clicking: jumpPressed
                };

                if (shipTrail.length === 0) {
                    shipTrail.push(currentPoint);
                } else {
                    const lastPoint = shipTrail[shipTrail.length - 1];
                    // If direction changed (click state changed), add a vertex
                    if (lastPoint.clicking !== jumpPressed) {
                        shipTrail.push(currentPoint);
                    } else {
                        // Otherwise, just update the last point to current position to extend the line
                        // This creates a perfect straight line and saves memory
                        shipTrail[shipTrail.length - 1] = currentPoint;
                    }
                }

                // Create trail particles - only at vertices (turns) for impact
                if (shipTrail.length > 1) {
                    const lastPoint = shipTrail[shipTrail.length - 1];
                    const prevPoint = shipTrail[shipTrail.length - 2];
                    // If we just added a new vertex (direction change), spawn particles there
                    if (lastPoint.x === currentPoint.x && lastPoint.y === currentPoint.y && lastPoint.clicking !== prevPoint.clicking) {
                        for (let i = 0; i < 5; i++) {
                            particles.push({
                                x: player.x,
                                y: player.y + player.height / 2,
                                vx: (Math.random() - 0.5) * 5,
                                vy: (Math.random() - 0.5) * 5,
                                life: 20,
                                color: '#00d4ff',
                                size: 2
                            });
                        }
                    }
                }

                // Keep ship in bounds
                if (player.y < 10) {
                    player.y = 10;
                    // Auto-switch direction at bounds if holding wrong way? 
                    // For standard wave, you just die usually, but let's slide for now or bounce?
                    // Let's slide but clamp velocity visuals
                }
                if (player.y > canvas.height - 50) {
                    player.y = canvas.height - 50;
                }
            } else {
                // Speed increase depends on round
                // Round 1: No speed increase
                // Round 2+: Gradual speed increase, more each round
                if (currentRound === 1) {
                    gameSpeed = GAME_SPEED_INITIAL; // Constant speed for round 1
                } else {
                    // Speed multiplier increases with round
                    const speedGrowthRate = 0.0001 + (currentRound - 2) * 0.00005; // Grows faster each round
                    const maxSpeed = GAME_SPEED_INITIAL + (currentRound - 1) * 1.5; // Higher max each round
                    const speedMultiplier = Math.pow(1 + speedGrowthRate, distanceTraveled);
                    gameSpeed = Math.min(GAME_SPEED_INITIAL * speedMultiplier, Math.min(maxSpeed, GAME_SPEED_MAX));
                }

                // Slow drop after exiting fly mode (when not jumping and in air)
                if (!player.isJumping && !player.onGround && !player.onPlatform && invincible) {
                    player.velocityY += 0.3; // Gentle gravity
                    player.velocityY = Math.min(player.velocityY, 4); // Cap fall speed
                    player.y += player.velocityY;
                }

                // Natural arc jump using sine curve (smooth and fast)
                if (player.isJumping) {
                    jumpProgress++;
                    // Use sine curve for natural arc (0 to PI maps to up and down)
                    const t = jumpProgress / JUMP_DURATION;
                    const arcHeight = Math.sin(t * Math.PI) * JUMP_HEIGHT;
                    player.y = jumpStartY - arcHeight;

                    // End jump when complete
                    if (jumpProgress >= JUMP_DURATION) {
                        player.isJumping = false;
                        jumpProgress = 0;
                    }
                }
            }

            // Check portal collision
            for (const portal of portals) {
                if (player.x + player.width > portal.x &&
                    player.x < portal.x + portal.width &&
                    player.y + player.height > portal.y &&
                    player.y < portal.y + portal.height) {

                    if (portal.type === 'shipEnter' && !shipMode && !wormholeTransition) {
                        // Start wormhole enter transition
                        wormholeTransition = true;
                        wormholeProgress = 0;
                        wormholeEntering = true;
                        wormholePlayerY = -50; // Start above screen
                        createPortalParticles(portal);
                    } else if (portal.type === 'shipExit' && shipMode && !wormholeTransition) {
                        // Start wormhole exit transition
                        wormholeTransition = true;
                        wormholeProgress = 0;
                        wormholeEntering = false;
                        wormholePlayerY = -50; // Start above screen
                        createPortalParticles(portal);
                    }
                }
            }

            // Check SECRET portal collision
            for (const secretPortal of secretPortals) {
                if (player.x + player.width > secretPortal.x &&
                    player.x < secretPortal.x + secretPortal.width &&
                    player.y + player.height > secretPortal.y &&
                    player.y < secretPortal.y + secretPortal.height &&
                    !secretAreaActive && !wormholeTransition) {
                    // Found the secret! Start cutscene
                    secretAreaActive = true;
                    secretAreaProgress = 0;
                    secretEntryX = player.x; // Save where player entered
                }
            }

            // Reset platform state
            player.onPlatform = false;

            // Check if player is over a pit (only in cube mode)
            let overPit = false;
            if (!shipMode) {
                for (const pit of pits) {
                    if (player.x + player.width > pit.x && player.x < pit.x + pit.width) {
                        overPit = true;
                        break;
                    }
                }
            }

            // Platform collision (skip in fly mode and ship mode)
            // Only land on platforms when moving down (second half of jump arc)
            if (!flyMode && !shipMode) {
                const isDescending = jumpProgress > JUMP_DURATION / 2;
                for (const platform of platforms) {
                    // Skip invisible disappearing platforms
                    if (platform.disappearing && platform.phase === 2) {
                        continue;
                    }

                    if (isDescending &&
                        player.x + player.width > platform.x &&
                        player.x < platform.x + platform.width &&
                        player.y + player.height >= platform.y &&
                        player.y + player.height <= platform.y + platform.height + 15) {

                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onPlatform = true;
                        player.isJumping = false;
                        jumpProgress = 0;
                    }
                }
            }

            // Ground/Pit collision logic
            if (!shipMode && !flyMode) {
                if (player.y >= canvas.height - GROUND_HEIGHT - player.height) {
                    // Check if falling into a pit
                    if (overPit && !player.onPlatform) {
                        // Fall through (but not if invincible - teleport to ground)
                        if (invincible) {
                            player.y = canvas.height - GROUND_HEIGHT - player.height;
                            player.onGround = true;
                            player.isJumping = false;
                            jumpProgress = 0;
                        } else if (player.y > canvas.height) {
                            gameOver();
                        }
                    } else {
                        // Land on ground
                        player.y = canvas.height - GROUND_HEIGHT - player.height;
                        player.onGround = true;
                        player.isJumping = false;
                        jumpProgress = 0;

                        // Reset rotation when landing
                        player.rotation = Math.round(player.rotation / (Math.PI / 2)) * (Math.PI / 2);
                    }
                }
            }

            // Prevent player from going off screen in fly mode
            if (player.y < 0) {
                player.y = 0;
                player.velocityY = 0;
            }

            // Rotate player when jumping (only in cube mode)
            if (!shipMode) {
                if (!player.onGround && !player.onPlatform && player.isJumping) {
                    // Rotate based on jump progress - exactly one full rotation per jump
                    const jumpT = jumpProgress / JUMP_DURATION;
                    player.rotation = jumpT * Math.PI * 2;
                } else if (player.onGround || player.onPlatform) {
                    // Snap to nearest 90 degrees when landing
                    player.rotation = Math.round(player.rotation / (Math.PI / 2)) * (Math.PI / 2);
                }
            } else {
                // Ship tilts based on velocity
                player.rotation = shipVelocityY * 0.05;
            }

            // Ground running particles
            if ((player.onGround || player.onPlatform) && !shipMode && Math.random() < 0.3) {
                particles.push({
                    x: player.x,
                    y: player.y + player.height,
                    vx: -gameSpeed * 0.5 + (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 2,
                    life: 15 + Math.random() * 10,
                    color: '#ffffff',
                    size: 2 + Math.random() * 2
                });
            }

            // Move obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= gameSpeed;
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                    score += 10;
                }
            }

            // Move orbs and check collision
            canOrbJump = false;
            currentOrb = null;
            for (let i = orbs.length - 1; i >= 0; i--) {
                orbs[i].x -= gameSpeed;
                if (orbs[i].x + orbs[i].width < 0) {
                    orbs.splice(i, 1);
                } else if (!orbs[i].used && !shipMode) {
                    // Check if player is touching the orb
                    if (player.x + player.width > orbs[i].x &&
                        player.x < orbs[i].x + orbs[i].width &&
                        player.y + player.height > orbs[i].y &&
                        player.y < orbs[i].y + orbs[i].height) {
                        canOrbJump = true;
                        currentOrb = orbs[i];
                    }
                }
            }

            // Move platforms
            for (let i = platforms.length - 1; i >= 0; i--) {
                platforms[i].x -= gameSpeed;
                if (platforms[i].x + platforms[i].width < 0) {
                    platforms.splice(i, 1);
                    score += 5;
                }
            }

            // Move pits
            for (let i = pits.length - 1; i >= 0; i--) {
                pits[i].x -= gameSpeed;
                if (pits[i].x + pits[i].width < 0) {
                    pits.splice(i, 1);
                }
            }

            // Move portals
            for (let i = portals.length - 1; i >= 0; i--) {
                portals[i].x -= gameSpeed;
                if (portals[i].x + portals[i].width < 0) {
                    portals.splice(i, 1);
                }
            }

            // Move secret portals
            for (let i = secretPortals.length - 1; i >= 0; i--) {
                secretPortals[i].x -= gameSpeed;
                if (secretPortals[i].x + secretPortals[i].width < 0) {
                    secretPortals.splice(i, 1);
                }
            }

            // Move tunnel walls
            for (let i = tunnelWalls.length - 1; i >= 0; i--) {
                tunnelWalls[i].x -= gameSpeed;
                if (tunnelWalls[i].x + tunnelWalls[i].width < 0) {
                    tunnelWalls.splice(i, 1);
                    score += 5;
                }
            }

            // Move finish line
            if (finishLine) {
                finishLine.x -= gameSpeed;

                // Check if player crossed finish line
                if (player.x + player.width > finishLine.x && player.x < finishLine.x + finishLine.width) {
                    winGame();
                    return;
                }
            }

            // Collision detection with obstacles (skip if fly mode or invincible)
            if (!flyMode && !invincible) {
                for (const obstacle of obstacles) {
                    if (checkCollision(player, obstacle)) {
                        gameOver();
                        return;
                    }
                }

                // Collision detection with tunnel walls (in ship mode)
                if (shipMode) {
                    for (const wall of tunnelWalls) {
                        if (checkTunnelCollision(player, wall)) {
                            gameOver();
                            return;
                        }
                    }
                }
            }

            // Particles are updated at the start of update() so they animate during death

            // Update ground offset
            groundOffset = (groundOffset + gameSpeed) % 40;
            bgOffset = (bgOffset + gameSpeed * 0.3) % 100;

            // Update score display (total + current round)
            scoreDisplay.textContent = `Score: ${totalScore + score}`;
        }

        function checkCollision(player, obstacle) {
            const padding = 8;
            const px = player.x + padding;
            const py = player.y + padding;
            const pw = player.width - padding * 2;
            const ph = player.height - padding * 2;

            if (obstacle.type === 'spike' || obstacle.type === 'longSpike') {
                // Triangle collision (simplified)
                if (px + pw > obstacle.x && px < obstacle.x + obstacle.width) {
                    if (py + ph > obstacle.y + obstacle.height * 0.3) {
                        return true;
                    }
                }
            } else if (obstacle.type === 'ceilingBlock') {
                // Rectangle collision for ceiling blocks
                if (px < obstacle.x + obstacle.width &&
                    px + pw > obstacle.x &&
                    py < obstacle.y + obstacle.height &&
                    py + ph > obstacle.y) {
                    return true;
                }
            } else if (obstacle.type === 'spikeDown') {
                // Upside down spike collision
                if (px + pw > obstacle.x && px < obstacle.x + obstacle.width) {
                    if (py < obstacle.y + obstacle.height * 0.7) {
                        return true;
                    }
                }
            } else if (obstacle.type === 'sawBlade') {
                // Circular collision for saw blade
                const cx = obstacle.x + obstacle.width / 2;
                const cy = obstacle.y + obstacle.height / 2;
                const radius = obstacle.width / 2 + 5; // Slightly larger hitbox

                const playerCx = px + pw / 2;
                const playerCy = py + ph / 2;

                const dx = playerCx - cx;
                const dy = playerCy - cy;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius + pw / 2) {
                    return true;
                }
            } else if (obstacle.type === 'box' || obstacle.type === 'step') {
                // Boxes and steps can be landed on top of, but hitting the sides kills you
                const onTop = player.velocityY >= 0 &&
                    py + ph >= obstacle.y &&
                    py + ph <= obstacle.y + 15 &&
                    px + pw > obstacle.x &&
                    px < obstacle.x + obstacle.width;

                if (onTop) {
                    // Land on box/step
                    player.y = obstacle.y - player.height;
                    player.velocityY = 0;
                    player.onPlatform = true;
                    player.isJumping = false;
                    return false;
                }

                // Check side collision
                if (px < obstacle.x + obstacle.width &&
                    px + pw > obstacle.x &&
                    py < obstacle.y + obstacle.height &&
                    py + ph > obstacle.y) {
                    return true;
                }
            } else {
                // Regular block collision
                if (px < obstacle.x + obstacle.width &&
                    px + pw > obstacle.x &&
                    py < obstacle.y + obstacle.height &&
                    py + ph > obstacle.y) {
                    return true;
                }
            }
            return false;
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Don't draw game when not running (on home page, skin shop, etc.)
            if (!gameRunning) {
                return;
            }

            // During wormhole transition, only draw the cutscene
            if (wormholeTransition) {
                drawWormholeEffect();
                return;
            }

            // During secret area cutscene, only draw that
            if (secretAreaActive) {
                drawSecretAreaCutscene();
                return;
            }

            // Draw background elements
            drawBackground();

            // Draw ground (with pits) - hide during ship mode
            if (!shipMode) {
                drawGround();
            }

            // Draw tunnel walls (ship mode)
            for (const wall of tunnelWalls) {
                if (wall.x < canvas.width + 50 && wall.x + wall.width > -50) {
                    drawTunnelWall(wall);
                }
            }

            // Draw portals
            for (const portal of portals) {
                if (portal.x < canvas.width + 100 && portal.x + portal.width > -50) {
                    drawPortal(portal);
                }
            }

            // Draw SECRET portals (sci-fi style)
            for (const secretPortal of secretPortals) {
                if (secretPortal.x < canvas.width + 100 && secretPortal.x + secretPortal.width > -50) {
                    secretPortal.shimmer = (secretPortal.shimmer || 0) + 0.1;
                    const pulse = secretPortal.shimmer;
                    const x = secretPortal.x;
                    const y = secretPortal.y;
                    const w = secretPortal.width;
                    const h = secretPortal.height;

                    // Outer glow
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 20 + Math.sin(pulse) * 8;

                    // Metallic frame
                    const frameGrad = ctx.createLinearGradient(x, y, x, y + h);
                    frameGrad.addColorStop(0, '#556677');
                    frameGrad.addColorStop(0.3, '#99aabb');
                    frameGrad.addColorStop(0.5, '#ffffff');
                    frameGrad.addColorStop(0.7, '#99aabb');
                    frameGrad.addColorStop(1, '#334455');
                    ctx.fillStyle = frameGrad;
                    ctx.fillRect(x - 5, y - 5, w + 10, h + 10);

                    // Inner void
                    ctx.fillStyle = '#000022';
                    ctx.fillRect(x, y, w, h);

                    // Energy rings inside
                    for (let i = 0; i < 4; i++) {
                        const ringY = y + h/2 + Math.sin(pulse * 2 + i * 0.8) * (h/3);
                        const ringAlpha = 0.4 + Math.sin(pulse + i) * 0.2;
                        ctx.strokeStyle = `rgba(0, 255, 255, ${ringAlpha})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.ellipse(x + w/2, ringY, w/2 - 3, 5, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Center glow
                    const coreGrad = ctx.createRadialGradient(x + w/2, y + h/2, 0, x + w/2, y + h/2, 25);
                    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                    coreGrad.addColorStop(0.5, 'rgba(0, 255, 255, 0.3)');
                    coreGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = coreGrad;
                    ctx.fillRect(x, y, w, h);

                    // Tech detail lines
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - 4, y + h * 0.3);
                    ctx.lineTo(x - 1, y + h * 0.3);
                    ctx.moveTo(x - 4, y + h * 0.7);
                    ctx.lineTo(x - 1, y + h * 0.7);
                    ctx.moveTo(x + w + 1, y + h * 0.3);
                    ctx.lineTo(x + w + 4, y + h * 0.3);
                    ctx.moveTo(x + w + 1, y + h * 0.7);
                    ctx.lineTo(x + w + 4, y + h * 0.7);
                    ctx.stroke();

                    ctx.shadowBlur = 0;
                }
            }

            // Draw orbs
            for (const orb of orbs) {
                if (orb.x < canvas.width + 50 && orb.x + orb.width > -50 && !orb.used) {
                    drawOrb(orb);
                }
            }

            // Draw finish line
            if (finishLine && finishLine.x < canvas.width + 100) {
                drawFinishLine();
            }

            // Draw platforms
            for (const platform of platforms) {
                if (platform.x < canvas.width + 50 && platform.x + platform.width > -50) {
                    drawPlatform(platform);
                }
            }

            // Draw obstacles
            for (const obstacle of obstacles) {
                if (obstacle.x < canvas.width + 50 && obstacle.x + obstacle.width > -50) {
                    drawObstacle(obstacle);
                }
            }

            // Draw player
            drawPlayer();

            // Draw particles
            for (const particle of particles) {
                ctx.globalAlpha = particle.life / 60;
                ctx.fillStyle = particle.color;
                const size = particle.size || 4;
                if (particle.isSquare) {
                    // Draw as square/cube
                    ctx.fillRect(particle.x - size / 2, particle.y - size / 2, size, size);
                } else {
                    // Draw as circle
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;

            // Draw spawn waves
            for (let i = spawnWaves.length - 1; i >= 0; i--) {
                const wave = spawnWaves[i];
                const maxLife = 40;  // Match the life value in createSpawnWaves
                const progress = 1 - (wave.life / maxLife);
                wave.radius = 5 + progress * (wave.maxRadius - 5);  // Start from 5
                wave.life--;

                ctx.globalAlpha = wave.life / maxLife;
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                ctx.stroke();

                if (wave.life <= 0) {
                    spawnWaves.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1;

            // Fly mode indicator
            if (flyMode) {
                drawGradientText('FLY MODE', 20, canvas.height - 20, 'bold 14px Orbitron', 'left', '#ffffff', '#ff66ff', '#aa22aa');
            }

            // Ship mode indicator
            if (shipMode && !flyMode) {
                drawGradientText('SHIP MODE', 20, canvas.height - 20, 'bold 14px Orbitron', 'left', '#ffffff', '#00d4ff', '#0066aa');
            }

            // Invincibility indicator
            if (invincible) {
                const secondsLeft = Math.ceil(invincibleTimer / 60);
                drawGradientText(`INVINCIBLE: ${secondsLeft}s`, 20, canvas.height - 40, 'bold 14px Orbitron', 'left', '#ffffff', '#ffff66', '#aa8800');
            }

            // Spawn countdown overlay (after wormhole transition)
            if (spawnCountdownActive) {
                const secondsLeft = Math.ceil(spawnCountdown / 60);
                // Semi-transparent overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Countdown number
                ctx.fillStyle = '#00d4ff';
                ctx.font = 'bold 120px Orbitron';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 30;
                ctx.fillText(secondsLeft > 0 ? secondsLeft : 'GO!', canvas.width / 2, canvas.height / 2 + 30);
                // Get Ready text
                ctx.font = 'bold 28px Orbitron';
                ctx.fillStyle = '#ffffff';
                ctx.fillText('Get Ready!', canvas.width / 2, canvas.height / 2 + 80);
                ctx.shadowBlur = 0;
            }
        }

        function drawWormholeEffect() {
            const cx = canvas.width / 2;

            if (wormholeEntering) {
                // ENTERING CUTSCENE: Player jumps over obstacle, sees hole, falls in
                // Phase 1: Jump over spike, land, walk to hole, peer in, fall (frames 0-420)
                // Phase 2: Falling down the hole (frames 420+)
                const PHASE1_END = 420;
                const groundY = canvas.height - 100;
                const holeX = cx + 50;
                const holeWidth = 120;
                const playerSize = 40;

                if (wormholeProgress < PHASE1_END) {
                    // ========== PHASE 1: GROUND SCENE ==========
                    const halfSize = playerSize / 2;

                    // BACKGROUND: Night sky gradient
                    const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    skyGrad.addColorStop(0, '#0a0a18');
                    skyGrad.addColorStop(0.5, '#1a1a3e');
                    skyGrad.addColorStop(1, '#2a3a5e');
                    ctx.fillStyle = skyGrad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // STARS: Twinkling stars
                    for (let i = 0; i < 40; i++) {
                        const sx = (i * 73 + 20) % canvas.width;
                        const sy = (i * 47 + 10) % (canvas.height - 120);
                        const twinkle = Math.sin(wormholeProgress * 0.1 + i) * 0.4 + 0.6;
                        ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 1 + twinkle * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // GROUND: Textured ground (with gap for hole)
                    ctx.fillStyle = '#1a3a5a';
                    ctx.fillRect(0, groundY, holeX, 100);
                    ctx.fillRect(holeX + holeWidth, groundY, canvas.width - holeX - holeWidth, 100);

                    // Ground texture lines
                    ctx.strokeStyle = '#2a4a6a';
                    ctx.lineWidth = 1;
                    for (let gx = 0; gx < canvas.width; gx += 25) {
                        if (gx < holeX || gx > holeX + holeWidth) {
                            ctx.beginPath();
                            ctx.moveTo(gx, groundY + 5);
                            ctx.lineTo(gx + 12, groundY + 25);
                            ctx.stroke();
                        }
                    }

                    // Ground top edge
                    ctx.strokeStyle = '#3a5a7a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, groundY);
                    ctx.lineTo(holeX, groundY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(holeX + holeWidth, groundY);
                    ctx.lineTo(canvas.width, groundY);
                    ctx.stroke();

                    // DOUBLE BOX OBSTACLE (2 boxes side by side [box][box])
                    const obstacleX = 120;
                    const boxSize = 40; // Same size as player
                    const boxY = groundY - boxSize; // Both boxes sitting on ground

                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 10;

                    // Draw left box (gradient: black at top -> white at bottom, same as game)
                    const boxGrad1 = ctx.createLinearGradient(obstacleX, boxY, obstacleX, boxY + boxSize);
                    boxGrad1.addColorStop(0, '#000000');
                    boxGrad1.addColorStop(0.5, '#666666');
                    boxGrad1.addColorStop(1, '#ffffff');
                    ctx.fillStyle = boxGrad1;
                    ctx.fillRect(obstacleX, boxY, boxSize, boxSize);
                    ctx.strokeStyle = '#00d4ff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obstacleX, boxY, boxSize, boxSize);

                    // Draw right box (next to left box, same gradient)
                    const boxGrad2 = ctx.createLinearGradient(obstacleX + boxSize, boxY, obstacleX + boxSize, boxY + boxSize);
                    boxGrad2.addColorStop(0, '#000000');
                    boxGrad2.addColorStop(0.5, '#666666');
                    boxGrad2.addColorStop(1, '#ffffff');
                    ctx.fillStyle = boxGrad2;
                    ctx.fillRect(obstacleX + boxSize, boxY, boxSize, boxSize);
                    ctx.strokeRect(obstacleX + boxSize, boxY, boxSize, boxSize);
                    ctx.shadowBlur = 0;

                    // HOLE: Mysterious glowing hole
                    const glowIntensity = Math.sin(wormholeProgress * 0.05) * 0.3 + 0.7;
                    const holeCenterX = holeX + holeWidth / 2;
                    const holeGlow = ctx.createRadialGradient(holeCenterX, groundY, 20, holeCenterX, groundY + 30, 120);
                    holeGlow.addColorStop(0, `rgba(0, 200, 255, ${glowIntensity * 0.4})`);
                    holeGlow.addColorStop(0.5, `rgba(0, 100, 200, ${glowIntensity * 0.2})`);
                    holeGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = holeGlow;
                    ctx.fillRect(holeX - 60, groundY - 60, holeWidth + 120, 120);

                    // The actual hole (black void)
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(holeX, groundY, holeWidth, 100);

                    // Hole edge glow
                    ctx.strokeStyle = '#00d4ff';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.moveTo(holeX, groundY);
                    ctx.lineTo(holeX, groundY + 30);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(holeX + holeWidth, groundY);
                    ctx.lineTo(holeX + holeWidth, groundY + 30);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Floating particles from hole
                    for (let i = 0; i < 6; i++) {
                        const pY = groundY - ((wormholeProgress * 1.5 + i * 40) % 100);
                        const pX = holeCenterX + Math.sin(wormholeProgress * 0.04 + i * 2) * 35;
                        const pAlpha = 1 - ((wormholeProgress * 1.5 + i * 40) % 100) / 100;
                        ctx.fillStyle = `rgba(0, 212, 255, ${pAlpha * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(pX, pY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // PLAYER POSITION CALCULATION
                    // Use EXACT game values: JUMP_DURATION=30, JUMP_HEIGHT=145, GAME_SPEED=6
                    let px = 0;
                    let py = 0;
                    let angle = 0;

                    // Obstacle is at x=120, player starts just before it to jump over
                    const jumpStartX = obstacleX - 20; // Start right before the boxes
                    const gameSpeed = 6; // Same as GAME_SPEED_INITIAL
                    const jumpDuration = 30; // Same as JUMP_DURATION
                    const jumpHeight = 145; // Same as JUMP_HEIGHT

                    if (wormholeProgress < jumpDuration) {
                        // JUMPING OVER BOXES: frames 0-30 (exact same as game)
                        const t = wormholeProgress / jumpDuration;
                        px = jumpStartX + wormholeProgress * gameSpeed; // Move at game speed
                        // Arc jump using exact same formula as game
                        py = groundY - playerSize - Math.sin(t * Math.PI) * jumpHeight;
                        angle = t * Math.PI * 2; // Full 360¬∞ rotation during jump
                    } else if (wormholeProgress < 50) {
                        // LANDING: frames 30-50
                        const landX = jumpStartX + jumpDuration * gameSpeed;
                        const t = (wormholeProgress - jumpDuration) / 20;
                        px = landX + (wormholeProgress - jumpDuration) * gameSpeed;
                        py = groundY - playerSize;
                        // Snap rotation to 0 (like in game)
                        angle = 0;
                    } else if (wormholeProgress < 150) {
                        // WALKING TO HOLE: frames 50-150
                        const walkStartX = jumpStartX + jumpDuration * gameSpeed + 20 * gameSpeed;
                        const t = (wormholeProgress - 50) / 100;
                        px = walkStartX + t * (holeX - 30 - walkStartX); // Walk closer to hole
                        const bounce = Math.abs(Math.sin(wormholeProgress * 0.3)) * 5;
                        py = groundY - playerSize - bounce;
                        angle = Math.sin(wormholeProgress * 0.3) * 0.1;
                    } else if (wormholeProgress < 210) {
                        // STOPPING AT HOLE: frames 150-210 (closer to hole)
                        px = holeX - 30;
                        py = groundY - playerSize;
                        angle = 0;
                    } else if (wormholeProgress < 300) {
                        // PEERING INTO HOLE: frames 210-300 (move even closer)
                        const t = (wormholeProgress - 210) / 90;
                        px = holeX - 30 + t * 30; // Move to edge of hole
                        py = groundY - playerSize + t * 15;
                        angle = t * 0.5;
                    } else if (wormholeProgress < 360) {
                        // WOBBLING ON EDGE: frames 300-360 (right at hole edge)
                        px = holeX;
                        py = groundY - playerSize + 15;
                        angle = 0.5 + Math.sin(wormholeProgress * 0.5) * 0.3;
                    } else {
                        // FALLING INTO HOLE: frames 360-420
                        const t = (wormholeProgress - 360) / 60;
                        px = holeX + t * 35;
                        py = groundY - playerSize + 15 + t * t * 350;
                        angle = 0.5 + t * Math.PI * 2;
                    }

                    // DUST PARTICLES when walking
                    if (wormholeProgress >= 50 && wormholeProgress < 150 && wormholeProgress % 8 < 4) {
                        ctx.fillStyle = 'rgba(100, 150, 200, 0.5)';
                        for (let d = 0; d < 3; d++) {
                            ctx.beginPath();
                            ctx.arc(px - 5 - d * 8, groundY - 3, 3 + Math.sin(wormholeProgress + d) * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // THOUGHT BUBBLE (frames 210-360)
                    if (wormholeProgress >= 210 && wormholeProgress < 360) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                        ctx.beginPath();
                        ctx.ellipse(px - 50, py - 25, 35, 22, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(px - 22, py - 5, 7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(px - 12, py + 5, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#333333';
                        ctx.font = 'bold 16px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.fillText('???', px - 50, py - 20);
                    }

                    // Floating question marks from hole
                    if (wormholeProgress >= 150 && wormholeProgress < 360) {
                        const qY1 = groundY - 20 - ((wormholeProgress - 150) % 80);
                        const qY2 = groundY - 20 - ((wormholeProgress - 150 + 40) % 80);
                        ctx.fillStyle = `rgba(0, 212, 255, 0.7)`;
                        ctx.font = 'bold 20px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.fillText('?', holeCenterX - 20 + Math.sin(wormholeProgress * 0.08) * 15, qY1);
                        ctx.fillText('?', holeCenterX + 20 + Math.cos(wormholeProgress * 0.08) * 15, qY2);
                    }

                    // AAAH! TEXT when falling
                    if (wormholeProgress >= 360) {
                        const shake = Math.sin(wormholeProgress * 0.8) * 4;
                        ctx.fillStyle = '#ff4444';
                        ctx.font = 'bold 28px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 10;
                        ctx.fillText('AAAH!', px + halfSize + shake, py - 20);
                        ctx.shadowBlur = 0;

                        // Motion lines
                        ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(px + halfSize - 25 + i * 12, py - 10 - i * 8);
                            ctx.lineTo(px + halfSize - 30 + i * 12, py - 30 - i * 8);
                            ctx.stroke();
                        }
                    }

                    // DRAW THE PLAYER (EXACT same style as drawNormalPlayer)
                    ctx.save();
                    ctx.translate(px + halfSize, py + halfSize);
                    ctx.rotate(angle);

                    const s = playerSize / 2; // Same as player.width / 2

                    // Cyan glow effect
                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 15;

                    // Dark outline/border
                    ctx.fillStyle = '#1a1a2e';
                    ctx.beginPath();
                    ctx.roundRect(-s - 2, -s - 2, playerSize + 4, playerSize + 4, 6);
                    ctx.fill();

                    // Orange/yellow gradient body
                    const bodyGradient = ctx.createLinearGradient(-s, -s, -s, s);
                    bodyGradient.addColorStop(0, '#ffcc00');
                    bodyGradient.addColorStop(0.3, '#ffa500');
                    bodyGradient.addColorStop(0.7, '#ff8c00');
                    bodyGradient.addColorStop(1, '#e67300');
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.roundRect(-s, -s, playerSize, playerSize, 4);
                    ctx.fill();

                    ctx.shadowBlur = 0;

                    // Dark face background (mouth area outline)
                    ctx.strokeStyle = '#1a1a2e';
                    ctx.lineWidth = 2;

                    // Eyes and mouth change based on emotion phase
                    if (wormholeProgress >= 360) {
                        // SCARED: Big eyes and O mouth
                        // Left eye (bigger, scared)
                        ctx.fillStyle = '#00d4ff';
                        ctx.fillRect(-s + 6, -s + 6, 12, 12);
                        ctx.strokeRect(-s + 6, -s + 6, 12, 12);
                        // Right eye
                        ctx.fillRect(s - 18, -s + 6, 12, 12);
                        ctx.strokeRect(s - 18, -s + 6, 12, 12);

                        // Scared eyebrows
                        ctx.strokeStyle = '#1a1a2e';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(-s + 4, -s + 3);
                        ctx.lineTo(-s + 20, -s + 6);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(s - 4, -s + 3);
                        ctx.lineTo(s - 20, -s + 6);
                        ctx.stroke();

                        // Screaming O mouth
                        ctx.fillStyle = '#00d4ff';
                        ctx.beginPath();
                        ctx.ellipse(0, s - 10, 8, 10, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#1a1a2e';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else if (wormholeProgress >= 200) {
                        // CURIOUS: Slightly bigger eyes and small O mouth
                        ctx.fillStyle = '#00d4ff';
                        ctx.fillRect(-s + 7, -s + 8, 11, 11);
                        ctx.strokeRect(-s + 7, -s + 8, 11, 11);
                        ctx.fillRect(s - 18, -s + 8, 11, 11);
                        ctx.strokeRect(s - 18, -s + 8, 11, 11);

                        // Curious small O mouth
                        ctx.fillStyle = '#00d4ff';
                        ctx.beginPath();
                        ctx.arc(0, s - 12, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#1a1a2e';
                        ctx.stroke();
                    } else {
                        // NORMAL: Exact same as drawNormalPlayer
                        // Left eye (cyan square)
                        ctx.fillStyle = '#00d4ff';
                        ctx.fillRect(-s + 8, -s + 10, 10, 10);
                        ctx.strokeStyle = '#1a1a2e';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(-s + 8, -s + 10, 10, 10);

                        // Right eye (cyan square)
                        ctx.fillStyle = '#00d4ff';
                        ctx.fillRect(s - 18, -s + 10, 10, 10);
                        ctx.strokeRect(s - 18, -s + 10, 10, 10);

                        // Mouth (wide cyan rectangle)
                        ctx.fillStyle = '#00d4ff';
                        ctx.fillRect(-s + 8, s - 16, playerSize - 16, 8);
                        ctx.strokeRect(-s + 8, s - 16, playerSize - 16, 8);
                    }

                    ctx.restore();

                } else {
                    // PHASE 2: Falling DOWN the deep hole (frames 420+)
                    // Elements move from BOTTOM to TOP (we're falling past them)
                    const fallProgress = wormholeProgress - PHASE1_END;
                    const FALL_DURATION = 300; // 5 seconds at 60fps

                    // Screen shake
                    const shakeIntensity = Math.max(1, 4 - fallProgress * 0.01);
                    const shakeX = Math.sin(fallProgress * 0.5) * shakeIntensity;
                    const shakeY = Math.cos(fallProgress * 0.7) * shakeIntensity;
                    ctx.save();
                    ctx.translate(shakeX, shakeY);

                    // Dark tunnel background - darker at bottom (abyss)
                    const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    bgGrad.addColorStop(0, '#0a0a15');
                    bgGrad.addColorStop(0.5, '#050510');
                    bgGrad.addColorStop(1, '#000005');
                    ctx.fillStyle = bgGrad;
                    ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

                    // Tunnel walls
                    const tunnelWidth = 320;
                    const tunnelLeft = cx - tunnelWidth / 2;
                    const tunnelRight = cx + tunnelWidth / 2;

                    // Rocky walls on sides
                    ctx.fillStyle = '#151520';
                    ctx.fillRect(0, 0, tunnelLeft, canvas.height);
                    ctx.fillRect(tunnelRight, 0, canvas.width - tunnelRight, canvas.height);

                    // Center void
                    ctx.fillStyle = '#020208';
                    ctx.fillRect(tunnelLeft, 0, tunnelWidth, canvas.height);

                    // Wall rocks - moving from BOTTOM to TOP (we fall past them)
                    const rockSpeed = 20;
                    for (let i = 0; i < 20; i++) {
                        const baseY = i * 40;
                        // Subtract to make them move UP (from bottom to top)
                        const rockY = canvas.height - ((baseY + fallProgress * rockSpeed) % (canvas.height + 80)) + 40;
                        const rockWidth = 25 + (i % 4) * 12;
                        const rockHeight = 10 + (i % 3) * 6;

                        ctx.fillStyle = `rgba(70, 75, 95, ${0.6 + (i % 3) * 0.1})`;
                        // Left wall rocks
                        ctx.fillRect(tunnelLeft - rockWidth + 5, rockY, rockWidth, rockHeight);
                        // Right wall rocks
                        ctx.fillRect(tunnelRight - 5, rockY + 20, rockWidth, rockHeight);
                    }

                    // Speed lines - moving from BOTTOM to TOP
                    const lineSpeed = 30;
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 28; i++) {
                        const baseY = i * 28;
                        // Move from bottom to top
                        const lineY = canvas.height - ((baseY + fallProgress * lineSpeed) % (canvas.height + 120)) + 60;
                        const xOffset = (i % 5) * 8;
                        const lineLen = 100 + (i % 3) * 40;

                        ctx.strokeStyle = `rgba(100, 180, 255, ${0.35 + (i % 3) * 0.1})`;
                        // Left lines - trail goes DOWN (we're falling)
                        ctx.beginPath();
                        ctx.moveTo(tunnelLeft + 10 + xOffset, lineY);
                        ctx.lineTo(tunnelLeft + 10 + xOffset, lineY - lineLen);
                        ctx.stroke();
                        // Right lines
                        ctx.beginPath();
                        ctx.moveTo(tunnelRight - 10 - xOffset, lineY + 10);
                        ctx.lineTo(tunnelRight - 10 - xOffset, lineY + 10 - lineLen);
                        ctx.stroke();
                    }

                    // Glowing rings - moving from BOTTOM to TOP
                    const ringSpeed = 18;
                    for (let i = 0; i < 12; i++) {
                        const baseY = i * 55;
                        const ringY = canvas.height - ((baseY + fallProgress * ringSpeed) % (canvas.height + 100)) + 50;
                        const ringSize = 90 + (i % 3) * 25;

                        ctx.strokeStyle = `rgba(0, 200, 255, 0.35)`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(cx, ringY, ringSize, 22, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Wind particles - moving from BOTTOM to TOP with trails going DOWN
                    const particleSpeed = 28;
                    for (let i = 0; i < 50; i++) {
                        const baseY = i * 18;
                        // Move from bottom to top
                        const pY = canvas.height - ((baseY + fallProgress * particleSpeed) % (canvas.height + 80)) + 40;
                        const baseX = tunnelLeft + 20 + ((i * 31) % (tunnelWidth - 40));
                        const wobble = Math.sin((fallProgress * 0.08) + i * 1.1) * 8;
                        const pX = baseX + wobble;
                        const pSize = 2 + (i % 3);

                        // Bright particle
                        ctx.fillStyle = `rgba(180, 230, 255, 0.8)`;
                        ctx.beginPath();
                        ctx.arc(pX, pY, pSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Trail going DOWN (shows we're falling past them)
                        const trailLen = 40 + (i % 4) * 20;
                        ctx.strokeStyle = `rgba(150, 210, 255, 0.5)`;
                        ctx.lineWidth = pSize * 0.7;
                        ctx.beginPath();
                        ctx.moveTo(pX, pY);
                        ctx.lineTo(pX, pY - trailLen); // Trail goes UP from particle (we're falling down)
                        ctx.stroke();
                    }

                    // Draw falling player at center, spinning
                    const s = playerSize / 2;
                    const rotation = fallProgress * 0.15;
                    const playerBobX = Math.sin(fallProgress * 0.04) * 8;
                    const playerBobY = Math.sin(fallProgress * 0.07) * 5;

                    ctx.save();
                    ctx.translate(cx + playerBobX, canvas.height / 2 + playerBobY);
                    ctx.rotate(rotation);

                    // Player glow
                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 20;

                    // Dark outline/border
                    ctx.fillStyle = '#1a1a2e';
                    ctx.beginPath();
                    ctx.roundRect(-s - 2, -s - 2, playerSize + 4, playerSize + 4, 6);
                    ctx.fill();

                    // Orange/yellow gradient body
                    const bodyGradient = ctx.createLinearGradient(-s, -s, -s, s);
                    bodyGradient.addColorStop(0, '#ffcc00');
                    bodyGradient.addColorStop(0.3, '#ffa500');
                    bodyGradient.addColorStop(0.7, '#ff8c00');
                    bodyGradient.addColorStop(1, '#e67300');
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.roundRect(-s, -s, playerSize, playerSize, 4);
                    ctx.fill();

                    ctx.shadowBlur = 0;

                    // NORMAL expression
                    ctx.strokeStyle = '#1a1a2e';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = '#00d4ff';
                    ctx.fillRect(-s + 8, -s + 10, 10, 10);
                    ctx.strokeRect(-s + 8, -s + 10, 10, 10);
                    ctx.fillRect(s - 18, -s + 10, 10, 10);
                    ctx.strokeRect(s - 18, -s + 10, 10, 10);
                    ctx.fillRect(-s + 8, s - 16, playerSize - 16, 8);
                    ctx.strokeRect(-s + 8, s - 16, playerSize - 16, 8);

                    ctx.restore();

                    // Motion blur lines ABOVE player (trailing behind as we fall)
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.7)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 10; i++) {
                        const blurX = cx + playerBobX + Math.sin(fallProgress * 0.06 + i * 0.7) * 20;
                        const blurY = canvas.height / 2 + playerBobY - 45 - i * 15;
                        ctx.beginPath();
                        ctx.moveTo(blurX, blurY);
                        ctx.lineTo(blurX, blurY - 40);
                        ctx.stroke();
                    }

                    // Light at TOP fading (the entrance we fell from)
                    const topAlpha = Math.max(0, 0.6 - fallProgress * 0.002);
                    const topGrad = ctx.createLinearGradient(0, 0, 0, 150);
                    topGrad.addColorStop(0, `rgba(150, 200, 255, ${topAlpha})`);
                    topGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = topGrad;
                    ctx.fillRect(0, 0, canvas.width, 150);

                    // Dark abyss at BOTTOM (where we're heading)
                    const abyssGrad = ctx.createLinearGradient(0, canvas.height - 150, 0, canvas.height);
                    abyssGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
                    abyssGrad.addColorStop(1, 'rgba(0, 0, 20, 0.98)');
                    ctx.fillStyle = abyssGrad;
                    ctx.fillRect(0, canvas.height - 150, canvas.width, 150);

                    ctx.restore(); // End screen shake

                    // "ENTERING SHIP MODE" text at top
                    ctx.save();
                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = 'bold 22px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('ENTERING SHIP MODE', cx, 45);
                    ctx.restore();

                    // "Click to Continue" after 5 seconds
                    if (fallProgress >= FALL_DURATION) {
                        const blink = Math.sin(Date.now() * 0.006) > 0;
                        if (blink) {
                            ctx.save();
                            ctx.fillStyle = '#ffffff';
                            ctx.font = 'bold 28px Orbitron';
                            ctx.textAlign = 'center';
                            ctx.shadowColor = '#00d4ff';
                            ctx.shadowBlur = 25;
                            ctx.fillText('CLICK TO CONTINUE', cx, canvas.height - 50);
                            ctx.restore();
                        }
                    }

                }
            } else {
                // EXITING CUTSCENE: Ship escapes the tunnel dramatically

                // Phase 1: Ship flies up through dark tunnel (frames 0-180)
                // Phase 2: Light appears above, ship approaches exit (frames 180-240)
                // Phase 3: Ship bursts out into daylight (frames 240-300)
                const exitPhase1End = 180;
                const exitPhase2End = 240;

                const scrollSpeed = 15;
                const scrollOffset = wormholeProgress * scrollSpeed;

                // Screen shake during escape
                const shakeIntensity = wormholeProgress < exitPhase2End ? 4 : 2;
                const shakeX = (Math.random() - 0.5) * shakeIntensity;
                const shakeY = (Math.random() - 0.5) * shakeIntensity;
                ctx.save();
                ctx.translate(shakeX, shakeY);

                if (wormholeProgress < exitPhase2End) {
                    // PHASE 1 & 2: Flying up through tunnel

                    // Dark tunnel background
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

                    // Tunnel walls
                    const tunnelWidth = 220;
                    const tunnelLeft = cx - tunnelWidth / 2;
                    const tunnelRight = cx + tunnelWidth / 2;

                    // Rock walls with texture
                    ctx.fillStyle = '#1a1a2a';
                    ctx.fillRect(0, 0, tunnelLeft, canvas.height);
                    ctx.fillRect(tunnelRight, 0, canvas.width - tunnelRight, canvas.height);

                    // Wall rocks/texture scrolling down
                    ctx.fillStyle = '#2a2a3a';
                    for (let i = 0; i < 12; i++) {
                        const rockY = (((i * 60 + scrollOffset) % (canvas.height + 80)) - 40);
                        ctx.fillRect(tunnelLeft - 25, rockY, 30, 15);
                        ctx.fillRect(tunnelRight - 5, rockY + 30, 30, 15);
                    }

                    // Void center
                    const voidGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    voidGradient.addColorStop(0, '#101020');
                    voidGradient.addColorStop(0.5, '#080815');
                    voidGradient.addColorStop(1, '#050508');
                    ctx.fillStyle = voidGradient;
                    ctx.fillRect(tunnelLeft, 0, tunnelWidth, canvas.height);

                    // Light from above (gets brighter in phase 2)
                    if (wormholeProgress > exitPhase1End) {
                        const lightProgress = (wormholeProgress - exitPhase1End) / (exitPhase2End - exitPhase1End);
                        const lightGradient = ctx.createRadialGradient(cx, -50, 10, cx, 100, 300);
                        lightGradient.addColorStop(0, `rgba(255, 255, 200, ${lightProgress * 0.8})`);
                        lightGradient.addColorStop(0.3, `rgba(200, 220, 255, ${lightProgress * 0.4})`);
                        lightGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        ctx.fillStyle = lightGradient;
                        ctx.fillRect(tunnelLeft, 0, tunnelWidth, canvas.height / 2);

                        // "Almost there!" text with gradient
                        ctx.globalAlpha = lightProgress * 0.9;
                        drawGradientText('ALMOST THERE!', cx, 50, 'bold 20px Orbitron', 'center', '#ffffff', '#88ccff', '#3388aa');
                        ctx.globalAlpha = 1;
                    }

                    // Speed lines rushing down past ship
                    ctx.strokeStyle = 'rgba(150, 200, 255, 0.6)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 15; i++) {
                        const lineX = tunnelLeft + 20 + (i % 6) * 35;
                        const lineY = (((i * 45 + scrollOffset * 1.5) % (canvas.height + 100)) - 50);
                        const lineLen = 60 + Math.sin(i) * 20;
                        ctx.beginPath();
                        ctx.moveTo(lineX, lineY);
                        ctx.lineTo(lineX, lineY + lineLen);
                        ctx.stroke();
                    }

                    // Rings flying down (ship going up)
                    for (let i = 0; i < 10; i++) {
                        const ringY = (((i * 70 + scrollOffset * 0.8) % (canvas.height + 150)) - 75);
                        const ringSize = 70 + (ringY / canvas.height) * 40;
                        ctx.strokeStyle = `rgba(80, 150, 200, ${0.4 - (ringY / canvas.height) * 0.2})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, ringY, ringSize, 12, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                } else {
                    // PHASE 3: Burst out into the sky!
                    const burstProgress = (wormholeProgress - exitPhase2End) / 60;

                    // Sky background
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    skyGradient.addColorStop(0, '#87CEEB');
                    skyGradient.addColorStop(0.5, '#4A90C2');
                    skyGradient.addColorStop(1, '#2E5A80');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(-10, -10, canvas.width + 20, canvas.height + 20);

                    // Sun burst effect
                    const sunGlow = ctx.createRadialGradient(cx, 80, 20, cx, 80, 200);
                    sunGlow.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    sunGlow.addColorStop(0.3, 'rgba(255, 220, 100, 0.5)');
                    sunGlow.addColorStop(1, 'rgba(255, 200, 50, 0)');
                    ctx.fillStyle = sunGlow;
                    ctx.fillRect(0, 0, canvas.width, 300);

                    // Clouds
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    for (let i = 0; i < 5; i++) {
                        const cloudX = (i * 180 + wormholeProgress * 0.5) % (canvas.width + 100) - 50;
                        const cloudY = 150 + i * 40 + Math.sin(i) * 30;
                        ctx.beginPath();
                        ctx.ellipse(cloudX, cloudY, 60, 25, 0, 0, Math.PI * 2);
                        ctx.ellipse(cloudX + 40, cloudY - 10, 40, 20, 0, 0, Math.PI * 2);
                        ctx.ellipse(cloudX - 30, cloudY + 5, 35, 18, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Ground below (distant)
                    ctx.fillStyle = '#2a5a30';
                    ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
                    ctx.fillStyle = '#3a7a40';
                    for (let x = 0; x < canvas.width; x += 40) {
                        ctx.beginPath();
                        ctx.moveTo(x, canvas.height - 80);
                        ctx.lineTo(x + 20, canvas.height - 100);
                        ctx.lineTo(x + 40, canvas.height - 80);
                        ctx.fill();
                    }

                    // "FREEDOM!" text with green gradient
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 5;
                    drawGradientText('FREEDOM!', cx, 50, 'bold 32px Orbitron', 'center', '#ffffff', '#66ff88', '#228844');
                    ctx.shadowBlur = 0;

                    // Celebration particles
                    for (let i = 0; i < 20; i++) {
                        const particleX = cx + Math.sin(wormholeProgress * 0.1 + i * 0.5) * (100 + i * 10);
                        const particleY = canvas.height / 2 - 50 + Math.cos(wormholeProgress * 0.15 + i * 0.7) * 80;
                        const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
                        ctx.fillStyle = colors[i % 4];
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 4 + Math.sin(i) * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw spaceship
                const shipY = wormholeProgress < exitPhase2End
                    ? canvas.height / 2
                    : canvas.height / 2 - ((wormholeProgress - exitPhase2End) / 60) * 50;
                const shipTilt = Math.sin(wormholeProgress * 0.1) * 0.1;
                const scale = 2.5;

                ctx.save();
                ctx.translate(cx, shipY);
                ctx.rotate(-Math.PI / 2 + shipTilt);
                ctx.scale(scale, scale);

                // Engine trail
                const trailLength = 50 + Math.sin(wormholeProgress * 0.3) * 10;
                const trailGradient = ctx.createLinearGradient(0, 0, -trailLength, 0);
                trailGradient.addColorStop(0, 'rgba(0, 255, 136, 0.8)');
                trailGradient.addColorStop(0.5, 'rgba(0, 200, 255, 0.4)');
                trailGradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
                ctx.fillStyle = trailGradient;
                ctx.beginPath();
                ctx.moveTo(-10, -12);
                ctx.lineTo(-10 - trailLength, 0);
                ctx.lineTo(-10, 12);
                ctx.closePath();
                ctx.fill();

                // Ship glow
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 30;

                // Ship body
                ctx.fillStyle = '#00d4ff';
                ctx.beginPath();
                ctx.moveTo(25, 0);
                ctx.lineTo(-15, -15);
                ctx.lineTo(-10, 0);
                ctx.lineTo(-15, 15);
                ctx.closePath();
                ctx.fill();

                // Cockpit window
                ctx.fillStyle = '#1a1a2e';
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(0, -8);
                ctx.lineTo(-5, 0);
                ctx.lineTo(0, 8);
                ctx.closePath();
                ctx.fill();

                // Engine flames
                const flameFlicker = Math.sin(wormholeProgress * 0.5) * 8;
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.moveTo(-10, -8);
                ctx.lineTo(-40 - flameFlicker, 0);
                ctx.lineTo(-10, 8);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(-10, -4);
                ctx.lineTo(-28 - flameFlicker * 0.5, 0);
                ctx.lineTo(-10, 4);
                ctx.closePath();
                ctx.fill();

                // Wings
                ctx.fillStyle = '#0099cc';
                ctx.beginPath();
                ctx.moveTo(-5, -10);
                ctx.lineTo(-15, -25);
                ctx.lineTo(-18, -20);
                ctx.lineTo(-12, -10);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(-5, 10);
                ctx.lineTo(-15, 25);
                ctx.lineTo(-18, 20);
                ctx.lineTo(-12, 10);
                ctx.closePath();
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.restore();

                // End screen shake
                ctx.restore();
            }

            // Fade in overlay only at very start
            const initialProgress = Math.min(wormholeProgress / 30, 1); // First 0.5 seconds
            if (initialProgress < 1) {
                const fadeAlpha = 1 - initialProgress;
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Text indicator
        }

        function drawSecretAreaCutscene() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const groundY = canvas.height - 80;
            const playerSize = 40;

            // SCI-FI SECRET DIMENSION
            // Phase 1 (0-60): Warp in effect
            // Phase 2 (60+): Player in sci-fi dimension, running to portal, then exits

            const PHASE1_END = 60;

            // Draw the EXACT same player as the game
            function drawGamePlayer(x, y, rotation) {
                ctx.save();
                ctx.translate(x + playerSize/2, y + playerSize/2);
                ctx.rotate(rotation);

                const s = playerSize / 2;

                // Cyan glow effect
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 15;

                // Dark outline/border
                ctx.fillStyle = '#1a1a2e';
                ctx.beginPath();
                ctx.roundRect(-s - 2, -s - 2, playerSize + 4, playerSize + 4, 6);
                ctx.fill();

                // Orange/yellow gradient body
                const bodyGradient = ctx.createLinearGradient(-s, -s, -s, s);
                bodyGradient.addColorStop(0, '#ffcc00');
                bodyGradient.addColorStop(0.3, '#ffa500');
                bodyGradient.addColorStop(0.7, '#ff8c00');
                bodyGradient.addColorStop(1, '#e67300');
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.roundRect(-s, -s, playerSize, playerSize, 4);
                ctx.fill();

                ctx.shadowBlur = 0;

                // Left eye (cyan square)
                ctx.fillStyle = '#00d4ff';
                ctx.fillRect(-s + 8, -s + 10, 10, 10);
                ctx.strokeStyle = '#1a1a2e';
                ctx.lineWidth = 2;
                ctx.strokeRect(-s + 8, -s + 10, 10, 10);

                // Right eye (cyan square)
                ctx.fillStyle = '#00d4ff';
                ctx.fillRect(s - 18, -s + 10, 10, 10);
                ctx.strokeRect(s - 18, -s + 10, 10, 10);

                // Mouth (wide cyan rectangle)
                ctx.fillStyle = '#00d4ff';
                ctx.fillRect(-s + 8, s - 16, playerSize - 16, 8);
                ctx.strokeRect(-s + 8, s - 16, playerSize - 16, 8);

                ctx.restore();
            }

            // Draw sci-fi portal
            function drawSciFiPortal(x, y, width, height, pulse) {
                // Outer glow
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 30 + Math.sin(pulse) * 10;

                // Portal frame - metallic look
                const frameGrad = ctx.createLinearGradient(x, y, x, y + height);
                frameGrad.addColorStop(0, '#667788');
                frameGrad.addColorStop(0.3, '#aabbcc');
                frameGrad.addColorStop(0.5, '#ffffff');
                frameGrad.addColorStop(0.7, '#aabbcc');
                frameGrad.addColorStop(1, '#445566');
                ctx.fillStyle = frameGrad;
                ctx.fillRect(x - 8, y - 8, width + 16, height + 16);

                // Inner black void
                ctx.fillStyle = '#000011';
                ctx.fillRect(x, y, width, height);

                // Swirling energy inside
                for (let i = 0; i < 5; i++) {
                    const ringY = y + height/2 + Math.sin(pulse * 2 + i) * (height/3);
                    const ringAlpha = 0.3 + Math.sin(pulse + i) * 0.2;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${ringAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(x + width/2, ringY, width/2 - 5, 8, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Center bright point
                const coreGrad = ctx.createRadialGradient(x + width/2, y + height/2, 0, x + width/2, y + height/2, 30);
                coreGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                coreGrad.addColorStop(0.5, 'rgba(0, 255, 255, 0.4)');
                coreGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = coreGrad;
                ctx.fillRect(x, y, width, height);

                // Tech lines on frame
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const lineY = y + (height / 5) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(x - 6, lineY);
                    ctx.lineTo(x - 2, lineY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x + width + 2, lineY);
                    ctx.lineTo(x + width + 6, lineY);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
            }

            if (secretAreaProgress < PHASE1_END) {
                // ========== PHASE 1: WARP IN ==========
                const t = secretAreaProgress / PHASE1_END;

                // Dark sci-fi background
                ctx.fillStyle = '#050510';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Warp lines rushing to center
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    const startDist = 400 * (1 - t);
                    const endDist = 50 * (1 - t);
                    const x1 = cx + Math.cos(angle) * startDist;
                    const y1 = cy + Math.sin(angle) * startDist;
                    const x2 = cx + Math.cos(angle) * endDist;
                    const y2 = cy + Math.sin(angle) * endDist;

                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 * t})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }

                // Flash at end
                if (t > 0.8) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${(t - 0.8) * 5})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

            } else {
                // ========== PHASE 2: SCI-FI DIMENSION ==========
                const dimProgress = secretAreaProgress - PHASE1_END;

                // Sci-fi background - dark with grid
                const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                bgGrad.addColorStop(0, '#0a0a20');
                bgGrad.addColorStop(0.5, '#101030');
                bgGrad.addColorStop(1, '#0a0a20');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Scrolling grid lines (sci-fi floor effect)
                const gridScroll = dimProgress * 3;
                ctx.strokeStyle = 'rgba(0, 150, 200, 0.3)';
                ctx.lineWidth = 1;

                // Horizontal lines (perspective)
                for (let i = 0; i < 15; i++) {
                    const baseY = groundY + 10 + i * 15;
                    if (baseY < canvas.height) {
                        ctx.beginPath();
                        ctx.moveTo(0, baseY);
                        ctx.lineTo(canvas.width, baseY);
                        ctx.stroke();
                    }
                }

                // Vertical lines (scrolling)
                for (let i = -1; i < 20; i++) {
                    const lineX = (i * 60 - gridScroll % 60);
                    ctx.beginPath();
                    ctx.moveTo(lineX, groundY);
                    ctx.lineTo(lineX, canvas.height);
                    ctx.stroke();
                }

                // Floating holographic panels in background
                for (let i = 0; i < 6; i++) {
                    const panelX = 50 + i * 140;
                    const panelY = 80 + Math.sin(dimProgress * 0.03 + i) * 20;
                    const panelAlpha = 0.1 + Math.sin(dimProgress * 0.05 + i) * 0.05;

                    ctx.fillStyle = `rgba(0, 200, 255, ${panelAlpha})`;
                    ctx.fillRect(panelX, panelY, 80, 50);
                    ctx.strokeStyle = `rgba(0, 255, 255, ${panelAlpha + 0.1})`;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(panelX, panelY, 80, 50);

                    // Data lines inside panel
                    for (let j = 0; j < 3; j++) {
                        const lineWidth = 20 + Math.random() * 40;
                        ctx.fillStyle = `rgba(0, 255, 255, ${panelAlpha + 0.1})`;
                        ctx.fillRect(panelX + 5, panelY + 10 + j * 12, lineWidth, 4);
                    }
                }

                // Ground platform (no spikes - safe sci-fi floor)
                const floorGrad = ctx.createLinearGradient(0, groundY, 0, canvas.height);
                floorGrad.addColorStop(0, '#223344');
                floorGrad.addColorStop(0.1, '#334455');
                floorGrad.addColorStop(1, '#112233');
                ctx.fillStyle = floorGrad;
                ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

                // Glowing edge on floor
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(0, groundY);
                ctx.lineTo(canvas.width, groundY);
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Exit portal on right side
                const portalX = canvas.width - 120;
                const portalY = groundY - 100;
                drawSciFiPortal(portalX, portalY, 60, 100, dimProgress * 0.1);

                // Player position - spawns on left, walks right
                const playerStartX = 80;
                const playerEndX = portalX - 60;
                const walkProgress = Math.min(1, dimProgress / 250);
                const playerX = playerStartX + (playerEndX - playerStartX) * walkProgress;
                const playerY = groundY - playerSize;

                // Gems display - top left corner (dark blue style)
                drawGradientText(`Gems: ${gems + Math.floor(dimProgress / 100)}`, 20, 35, 'bold 18px Orbitron', 'left', '#4466aa', '#223366', '#112244');

                // Check if player should be jumping into portal
                const isJumping = walkProgress >= 1 && dimProgress > 280;
                const enterProgress = isJumping ? (dimProgress - 280) / 120 : 0;

                // Draw player - either walking, standing, or jumping
                if (!isJumping || enterProgress >= 1) {
                    // Walking or standing player (not during jump animation)
                    if (!isJumping) {
                        const bounce = walkProgress < 1 ? Math.abs(Math.sin(dimProgress * 0.3)) * 8 : 0;
                        const rotation = walkProgress < 1 ? Math.sin(dimProgress * 0.3) * 0.15 : 0;
                        drawGamePlayer(playerX, playerY - bounce, rotation);

                        // Dust particles while walking
                        if (walkProgress < 1 && dimProgress % 8 < 4) {
                            for (let d = 0; d < 3; d++) {
                                ctx.fillStyle = `rgba(100, 150, 200, ${0.4 - d * 0.1})`;
                                ctx.beginPath();
                                ctx.arc(playerX - 5 - d * 10, groundY - 3, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                } else {
                    // Player jumping INTO the portal
                    const jumpPhase = enterProgress;
                    const jumpHeight = Math.sin(jumpPhase * Math.PI) * 80;
                    const jumpX = playerEndX + (portalX + 30 - playerEndX) * jumpPhase;
                    const jumpY = playerY - jumpHeight - (jumpPhase * 40);

                    // Shrink as entering portal
                    const shrink = jumpPhase > 0.6 ? 1 - ((jumpPhase - 0.6) / 0.4) * 0.8 : 1;

                    ctx.save();
                    ctx.translate(jumpX + playerSize/2, jumpY + playerSize/2);
                    ctx.scale(shrink, shrink);
                    ctx.rotate(jumpPhase * Math.PI * 2);
                    ctx.translate(-playerSize/2, -playerSize/2);
                    drawGamePlayer(0, 0, 0);
                    ctx.restore();

                    // Flash effect as entering
                    if (enterProgress > 0.8) {
                        const flashAlpha = (enterProgress - 0.8) / 0.2;
                        ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }

                // Exit animation - player jumping out of portal back to surface
                if (isJumping && enterProgress >= 1 && enterProgress < 2) {
                    // Transition scene - show player jumping OUT of portal back to surface
                    const exitPhase = enterProgress - 1;

                    // Draw game-like background (covers the sci-fi dimension)
                    const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    bgGrad.addColorStop(0, '#0a0a18');
                    bgGrad.addColorStop(0.5, '#0f1a30');
                    bgGrad.addColorStop(1, '#0f3460');
                    ctx.fillStyle = bgGrad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Ground
                    ctx.fillStyle = '#0f3460';
                    ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
                    ctx.fillStyle = '#00d4ff';
                    ctx.fillRect(0, groundY, canvas.width, 3);

                    // Portal on left side
                    const exitPortalX = 100;
                    const exitPortalY = groundY - 100;
                    drawSciFiPortal(exitPortalX, exitPortalY, 60, 100, dimProgress * 0.1);

                    // Player jumping OUT of portal
                    const jumpOutHeight = Math.sin(exitPhase * Math.PI) * 100;
                    const jumpOutX = exitPortalX + 30 + exitPhase * 150;
                    const jumpOutY = exitPortalY + 50 - jumpOutHeight;

                    // Scale up from small (exiting portal) to normal
                    const scaleUp = exitPhase < 0.3 ? 0.2 + (exitPhase / 0.3) * 0.8 : 1;

                    ctx.save();
                    ctx.translate(jumpOutX, jumpOutY);
                    ctx.scale(scaleUp, scaleUp);
                    ctx.rotate(-exitPhase * Math.PI * 1.5); // Spin opposite direction
                    drawGamePlayer(-playerSize/2, -playerSize/2, 0);
                    ctx.restore();

                    // Gems collected text
                    const textAlpha = exitPhase < 0.7 ? 1 : 1 - ((exitPhase - 0.7) / 0.3);
                    ctx.globalAlpha = textAlpha;
                    drawGradientText('+3 GEMS!', cx, 80, 'bold 48px Orbitron', 'center', '#4466aa', '#223366', '#112244');
                    ctx.globalAlpha = 1;

                    // Flash at start
                    if (exitPhase < 0.15) {
                        const flashAlpha = 1 - (exitPhase / 0.15);
                        ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }

                // End cutscene after jump out animation
                if (isJumping && enterProgress >= 2) {
                    secretAreaActive = false;
                    secretAreaProgress = 0;
                    secretAreaFound = true;
                    gems += 3;
                    totalGemsEver += 3;
                    localStorage.setItem('totalGemsEver', totalGemsEver);

                    // Position player in front of the SAME portal they entered
                    // Find the secret portal they entered and position in front of it
                    for (const sp of secretPortals) {
                        if (Math.abs(sp.x - secretEntryX) < 100) {
                            player.x = sp.x + sp.width + 30;
                            break;
                        }
                    }
                    // Fallback if portal moved off screen
                    if (player.x < 50) {
                        player.x = 100;
                    }
                    player.y = canvas.height - GROUND_HEIGHT - playerSize;
                    player.velocityY = 0;
                    player.rotation = 0;
                    player.isJumping = false;

                    // Update gems display
                    document.getElementById('gems').textContent = `Gems: ${gems}`;

                    spawnCountdown = 120;
                    spawnCountdownActive = true;
                }
            }
        }

        function drawBackground() {
            // Clean gradient background matching the ground color theme
            const spaceGradient = ctx.createLinearGradient(0, 0, 0, canvas.height - GROUND_HEIGHT);
            spaceGradient.addColorStop(0, '#0a0a18');
            spaceGradient.addColorStop(0.5, '#0f1a30');
            spaceGradient.addColorStop(1, '#0f3460');
            ctx.fillStyle = spaceGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height - GROUND_HEIGHT);

            // Draw simple twinkling stars
            for (const star of stars) {
                star.twinkle += 0.03;
                const twinkleBrightness = star.brightness + Math.sin(star.twinkle) * 0.15;

                // Move stars slowly (parallax effect)
                star.x -= star.speed;
                if (star.x < -5) {
                    star.x = canvas.width + 5;
                    star.y = Math.random() * 350;
                }

                // Draw simple star
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${twinkleBrightness})`;
                ctx.fill();
            }
        }

        function drawHexagon(cx, cy, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                const x = cx + size * Math.cos(angle);
                const y = cy + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        }

        function drawGround() {
            // Draw the full ground (extended for camera offset)
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(-50, canvas.height - GROUND_HEIGHT, canvas.width + 100, GROUND_HEIGHT);

            // Geometric pattern on ground - subtle hexagonal grid
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.15)';
            ctx.lineWidth = 1;
            const hexSize = 30;
            const hexHeight = hexSize * Math.sqrt(3);
            for (let row = 0; row < 3; row++) {
                for (let col = -2; col < canvas.width / (hexSize * 1.5) + 3; col++) {
                    const cx = col * hexSize * 1.5 - (groundOffset % (hexSize * 1.5));
                    const cy = canvas.height - GROUND_HEIGHT + 25 + row * hexHeight * 0.5;
                    if (row % 2 === 1) {
                        drawHexagon(cx + hexSize * 0.75, cy, hexSize * 0.4);
                    } else {
                        drawHexagon(cx, cy, hexSize * 0.4);
                    }
                }
            }

            // Draw ground top line
            ctx.fillStyle = '#00d4ff';
            ctx.fillRect(-50, canvas.height - GROUND_HEIGHT, canvas.width + 100, 3);

            // Draw pits over the ground
            for (const pit of pits) {
                if (pit.x < canvas.width && pit.x + pit.width > 0) {
                    // Draw pit as dark void
                    ctx.fillStyle = '#0a0a15';
                    ctx.fillRect(pit.x, canvas.height - GROUND_HEIGHT, pit.width, GROUND_HEIGHT);

                    // Danger triangles on edges
                    ctx.fillStyle = '#ff4444';
                    // Left edge triangles
                    for (let ty = canvas.height - GROUND_HEIGHT; ty < canvas.height; ty += 20) {
                        ctx.beginPath();
                        ctx.moveTo(pit.x, ty);
                        ctx.lineTo(pit.x + 10, ty + 10);
                        ctx.lineTo(pit.x, ty + 20);
                        ctx.closePath();
                        ctx.fill();
                    }
                    // Right edge triangles
                    for (let ty = canvas.height - GROUND_HEIGHT; ty < canvas.height; ty += 20) {
                        ctx.beginPath();
                        ctx.moveTo(pit.x + pit.width, ty);
                        ctx.lineTo(pit.x + pit.width - 10, ty + 10);
                        ctx.lineTo(pit.x + pit.width, ty + 20);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Spikes at bottom
                    ctx.fillStyle = '#ff6b6b';
                    const spikeCount = Math.floor(pit.width / 35);
                    const spikeWidth = pit.width / spikeCount;
                    for (let i = 0; i < spikeCount; i++) {
                        const sx = pit.x + i * spikeWidth;
                        ctx.beginPath();
                        ctx.moveTo(sx, canvas.height);
                        ctx.lineTo(sx + spikeWidth / 2, canvas.height - 18);
                        ctx.lineTo(sx + spikeWidth, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
        }

        function drawFinishLine() {
            // Vertical finish line from top to bottom
            ctx.save();
            const squareSize = 15;
            const lineWidth = 30; // Width of the finish line
            const lineHeight = canvas.height; // Full height from top to bottom

            // Draw checkered pattern vertically
            for (let row = 0; row < lineHeight / squareSize; row++) {
                for (let col = 0; col < lineWidth / squareSize; col++) {
                    ctx.fillStyle = (row + col) % 2 === 0 ? '#ffffff' : '#000000';
                    ctx.fillRect(
                        finishLine.x + col * squareSize,
                        row * squareSize,
                        squareSize,
                        squareSize
                    );
                }
            }

            // Glow effect
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 20;
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 3;
            ctx.strokeRect(finishLine.x, 0, lineWidth, lineHeight);

            // "FINISH" text - vertical with gradient
            ctx.shadowBlur = 0;
            ctx.save();
            ctx.translate(finishLine.x + lineWidth + 20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            // Create horizontal gradient (which appears vertical after rotation)
            const finishGradient = ctx.createLinearGradient(-40, -10, 40, 10);
            finishGradient.addColorStop(0, '#ffffff');
            finishGradient.addColorStop(0.5, '#66ff88');
            finishGradient.addColorStop(1, '#228844');
            ctx.fillStyle = finishGradient;
            ctx.font = 'bold 18px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('FINISH', 0, 0);
            ctx.restore();

            ctx.restore();
        }

        function drawPlatform(platform) {
            const x = platform.x;
            const y = platform.y;
            const w = platform.width;
            const h = platform.height;

            // Handle disappearing platforms
            if (platform.disappearing) {
                // Update timer and phase
                platform.timer++;
                const cycleLength = 90; // frames per phase

                if (platform.timer >= cycleLength) {
                    platform.timer = 0;
                    platform.phase = (platform.phase + 1) % 4;
                }

                // Calculate opacity based on phase
                let opacity = 1;
                if (platform.phase === 0) {
                    opacity = 1; // Fully visible
                } else if (platform.phase === 1) {
                    opacity = 1 - (platform.timer / cycleLength); // Fading out
                } else if (platform.phase === 2) {
                    opacity = 0; // Invisible
                    return; // Don't draw at all when invisible
                } else if (platform.phase === 3) {
                    opacity = platform.timer / cycleLength; // Fading in
                }

                ctx.globalAlpha = opacity;

                // Draw with warning colors when fading
                if (platform.phase === 1) {
                    // Flashing red warning
                    const flash = Math.sin(platform.timer * 0.5) > 0;
                    ctx.fillStyle = flash ? '#ff4444' : '#ff8888';
                } else {
                    ctx.fillStyle = '#aa66ff'; // Purple for disappearing platforms
                }
                ctx.fillRect(x, y, w, h);

                // Top highlight
                ctx.fillStyle = platform.phase === 1 ? '#ff8888' : '#cc88ff';
                ctx.fillRect(x, y, w, 3);

                ctx.globalAlpha = 1;
                return;
            }

            // Normal platform drawing
            // Platform body
            ctx.fillStyle = '#00ff88';
            ctx.fillRect(x, y, w, h);

            // Top highlight
            ctx.fillStyle = '#66ffaa';
            ctx.fillRect(x, y, w, 3);

            // Bottom edge
            ctx.fillStyle = '#00aa55';
            ctx.fillRect(x, y + h - 3, w, 3);

            // Geometric triangle pattern along platform
            ctx.fillStyle = '#00cc66';
            const triSize = 12;
            for (let tx = x + 6; tx < x + w - 6; tx += triSize + 4) {
                ctx.beginPath();
                ctx.moveTo(tx, y + h - 4);
                ctx.lineTo(tx + triSize / 2, y + 4);
                ctx.lineTo(tx + triSize, y + h - 4);
                ctx.closePath();
                ctx.fill();
            }
        }

        function drawPortal(portal) {
            const x = portal.x;
            const y = portal.y;
            const w = portal.width;
            const h = portal.height;
            const cx = x + w / 2;
            const cy = y + h / 2;

            // Animated rotation
            const time = Date.now() * 0.003;
            const pulse = Math.sin(time * 2) * 0.3 + 1;

            ctx.save();

            // Set colors based on portal type
            const color1 = portal.type === 'shipEnter' ? '#ff00ff' : '#00ff88';
            const color2 = portal.type === 'shipEnter' ? '#ff66ff' : '#66ffaa';
            const color3 = portal.type === 'shipEnter' ? '#aa00aa' : '#00aa55';

            // Outer glow rings (multiple)
            for (let i = 3; i >= 0; i--) {
                ctx.shadowColor = color1;
                ctx.shadowBlur = 30 - i * 5;
                ctx.strokeStyle = color1;
                ctx.globalAlpha = 0.3 - i * 0.05;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.ellipse(cx, cy, w / 2 + 10 + i * 8, h / 2 + i * 5, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Spinning outer ring
            ctx.globalAlpha = 0.8;
            ctx.strokeStyle = color2;
            ctx.lineWidth = 4;
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.ellipse(cx, cy, w / 2 + 5, h / 2, time, 0, Math.PI * 2);
            ctx.stroke();

            // Inner rotating arcs
            ctx.lineWidth = 3;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(cx, cy, w / 2 - 10, time + i * Math.PI / 2, time + i * Math.PI / 2 + Math.PI / 3);
                ctx.stroke();
            }

            // Gradient fill center
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, w / 2);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, color2);
            gradient.addColorStop(0.7, color1);
            gradient.addColorStop(1, color3);
            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.ellipse(cx, cy, w / 2 - 8, h / 2 - 20, 0, 0, Math.PI * 2);
            ctx.fill();

            // Swirling particles inside
            ctx.globalAlpha = 0.9;
            for (let i = 0; i < 6; i++) {
                const angle = time * 2 + i * Math.PI / 3;
                const dist = 15 + Math.sin(time * 3 + i) * 10;
                const px = cx + Math.cos(angle) * dist;
                const py = cy + Math.sin(angle) * dist * 0.5;
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(px, py, 3 * pulse, 0, Math.PI * 2);
                ctx.fill();
            }

            // Center bright spot
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.ellipse(cx, cy, 6 * pulse, 15 * pulse, 0, 0, Math.PI * 2);
            ctx.fill();

            // Spawn particles
            if (Math.random() < 0.3) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x: cx + Math.cos(angle) * (w / 2),
                    y: cy + Math.sin(angle) * (h / 2) * 0.5,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    life: 20 + Math.random() * 15,
                    color: color2,
                    size: 2 + Math.random() * 2
                });
            }

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        function drawOrb(orb) {
            const x = orb.x;
            const y = orb.y;
            const w = orb.width;
            const h = orb.height;

            const centerX = x + w / 2;
            const ballY = y;
            const rodBottom = y + h;

            // Blinking effect using time - slower blink
            const time = Date.now() * 0.001; // Slower speed
            const blink = 0.7 + Math.sin(time + orb.x * 0.05) * 0.3; // Gentler oscillation

            // Create tiny spark particles (sizzling effect) - less frequent
            if (Math.random() < 0.15 && !orb.used) {
                particles.push({
                    x: centerX + (Math.random() - 0.5) * 8,
                    y: ballY + 8 + (Math.random() - 0.5) * 8,
                    vx: (Math.random() - 0.5) * 1.5,
                    vy: -Math.random() * 1.5 - 0.3,
                    life: 10 + Math.random() * 10,
                    color: '#ffffff',
                    size: 0.8 + Math.random() * 1 // Even tinier sparks
                });
            }

            ctx.save();

            // Glow effect - pulses with blink
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 5 + blink * 5;

            if (canOrbJump && currentOrb === orb) {
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 15;
            }

            // Rod/pole
            ctx.fillStyle = '#666666';
            ctx.fillRect(centerX - 2, ballY + 10, 4, h - 10);

            // Rod base
            ctx.fillStyle = '#444444';
            ctx.fillRect(centerX - 5, rodBottom - 4, 10, 4);

            // White glowing ball on top - HALF SIZE, slight pulse
            const ballRadius = 5 + blink * 1.5;
            ctx.beginPath();
            ctx.arc(centerX, ballY + 6, ballRadius, 0, Math.PI * 2);

            // Gradient for 3D effect - brightness changes with blink
            const gradient = ctx.createRadialGradient(centerX - 1, ballY + 4, 1, centerX, ballY + 6, ballRadius);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, `rgba(255, 255, ${Math.floor(220 + blink * 35)}, ${blink})`);
            gradient.addColorStop(1, `rgba(255, ${Math.floor(220 + blink * 35)}, 150, ${0.7 + blink * 0.3})`);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Highlight - also pulses
            ctx.globalAlpha = 0.6 + blink * 0.4;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(centerX - 1.5, ballY + 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Ring around ball when active
            if (canOrbJump && currentOrb === orb) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(centerX, ballY + 6, 10, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawTunnelWall(wall) {
            const x = wall.x;
            const y = wall.y;
            const w = wall.width;
            const h = wall.height;

            ctx.save();

            if (wall.type === 'tunnelTop') {
                // Clip to wall bounds
                ctx.beginPath();
                ctx.rect(x, y, w, h + 40);
                ctx.clip();

                // Dark gray background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(x, y, w, h);

                // Silver/white diamond grid pattern (slower movement)
                ctx.strokeStyle = 'rgba(200, 200, 210, 0.15)';
                ctx.lineWidth = 1;
                const gridSize = 20;
                const slowOffset = groundOffset * 0.3; // Slower background scroll
                for (let row = 0; row < Math.ceil(h / gridSize) + 1; row++) {
                    for (let col = -1; col < Math.ceil(w / gridSize) + 2; col++) {
                        const cx = x + col * gridSize - (slowOffset % gridSize);
                        const cy = y + row * gridSize;
                        if (cy < y + h - 5) {
                            // Draw diamond shape
                            ctx.beginPath();
                            ctx.moveTo(cx, cy - gridSize * 0.4);
                            ctx.lineTo(cx + gridSize * 0.4, cy);
                            ctx.lineTo(cx, cy + gridSize * 0.4);
                            ctx.lineTo(cx - gridSize * 0.4, cy);
                            ctx.closePath();
                            ctx.stroke();
                        }
                    }
                }

                // Silver edge line
                ctx.fillStyle = '#c0c0c0';
                ctx.fillRect(x, y + h - 2, w, 3);

                // Spikes pointing down - black to white gradient
                const spikeWidth = 40;
                const spikeHeight = 35;
                const numSpikes = Math.floor(w / spikeWidth);
                const startOffset = (w - numSpikes * spikeWidth) / 2;

                for (let i = 0; i < numSpikes; i++) {
                    const sx = x + startOffset + i * spikeWidth;

                    // Gradient from dark (base) to white (tip)
                    const spikeGradient = ctx.createLinearGradient(sx + spikeWidth / 2, y + h, sx + spikeWidth / 2, y + h + spikeHeight);
                    spikeGradient.addColorStop(0, '#111111');
                    spikeGradient.addColorStop(0.4, '#555555');
                    spikeGradient.addColorStop(0.7, '#aaaaaa');
                    spikeGradient.addColorStop(1, '#ffffff');
                    ctx.fillStyle = spikeGradient;

                    ctx.beginPath();
                    ctx.moveTo(sx + 2, y + h);
                    ctx.lineTo(sx + spikeWidth / 2, y + h + spikeHeight);
                    ctx.lineTo(sx + spikeWidth - 2, y + h);
                    ctx.closePath();
                    ctx.fill();

                    // White outline
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }

            } else if (wall.type === 'tunnelBottom') {
                // Clip to wall bounds
                ctx.beginPath();
                ctx.rect(x, y - 40, w, h + 40);
                ctx.clip();

                // Dark gray background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(x, y, w, h);

                // Silver/white diamond grid pattern (slower movement)
                ctx.strokeStyle = 'rgba(200, 200, 210, 0.15)';
                ctx.lineWidth = 1;
                const gridSize = 20;
                const slowOffset = groundOffset * 0.3; // Slower background scroll
                for (let row = 0; row < Math.ceil(h / gridSize) + 1; row++) {
                    for (let col = -1; col < Math.ceil(w / gridSize) + 2; col++) {
                        const cx = x + col * gridSize - (slowOffset % gridSize);
                        const cy = y + row * gridSize;
                        if (cy > y + 5 && cy < y + h) {
                            // Draw diamond shape
                            ctx.beginPath();
                            ctx.moveTo(cx, cy - gridSize * 0.4);
                            ctx.lineTo(cx + gridSize * 0.4, cy);
                            ctx.lineTo(cx, cy + gridSize * 0.4);
                            ctx.lineTo(cx - gridSize * 0.4, cy);
                            ctx.closePath();
                            ctx.stroke();
                        }
                    }
                }

                // Silver edge line
                ctx.fillStyle = '#c0c0c0';
                ctx.fillRect(x, y, w, 3);

                // Spikes pointing up - black to white gradient
                const spikeWidth = 40;
                const spikeHeight = 35;
                const numSpikes = Math.floor(w / spikeWidth);
                const startOffset = (w - numSpikes * spikeWidth) / 2;

                for (let i = 0; i < numSpikes; i++) {
                    const sx = x + startOffset + i * spikeWidth;

                    // Gradient from dark (base) to white (tip)
                    const spikeGradient = ctx.createLinearGradient(sx + spikeWidth / 2, y, sx + spikeWidth / 2, y - spikeHeight);
                    spikeGradient.addColorStop(0, '#111111');
                    spikeGradient.addColorStop(0.4, '#555555');
                    spikeGradient.addColorStop(0.7, '#aaaaaa');
                    spikeGradient.addColorStop(1, '#ffffff');
                    ctx.fillStyle = spikeGradient;

                    ctx.beginPath();
                    ctx.moveTo(sx + 2, y);
                    ctx.lineTo(sx + spikeWidth / 2, y - spikeHeight);
                    ctx.lineTo(sx + spikeWidth - 2, y);
                    ctx.closePath();
                    ctx.fill();

                    // White outline
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        function drawPlayer() {
            // Don't draw player if not visible (dead) or during wormhole transition
            if (!player.visible || wormholeTransition) return;

            // Draw ship trail first (behind the ship)
            if (shipMode && shipTrail.length > 1) {
                // Move trail points with the game scroll
                for (let i = 0; i < shipTrail.length; i++) {
                    shipTrail[i].x -= gameSpeed;
                }
                // Remove off-screen points only (trail lasts longer)
                while (shipTrail.length > 0 && shipTrail[0].x < -400) {
                    shipTrail.shift();
                }

                // Draw trail segments with different colors for clicking vs not clicking
                ctx.lineWidth = 2;
                ctx.shadowBlur = 8;

                for (let i = 1; i < shipTrail.length; i++) {
                    ctx.beginPath();
                    ctx.moveTo(shipTrail[i - 1].x, shipTrail[i - 1].y);
                    ctx.lineTo(shipTrail[i].x, shipTrail[i].y);

                    // Green when clicking (going up), cyan when not (falling)
                    if (shipTrail[i].clicking) {
                        ctx.strokeStyle = '#00ff88';
                        ctx.shadowColor = '#00ff88';
                    } else {
                        ctx.strokeStyle = '#00d4ff';
                        ctx.shadowColor = '#00d4ff';
                    }
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
            }

            ctx.save();
            ctx.translate(player.x + player.width / 2, player.y + player.height / 2);

            if (flyMode) {
                // Draw aircraft in fly mode
                drawAircraft();
            } else if (shipMode) {
                // Draw ship in ship mode
                ctx.rotate(player.rotation);
                drawShip();
            } else {
                ctx.rotate(player.rotation);
                drawNormalPlayer();
            }

            ctx.restore();
        }

        function drawShip() {
            // Get current skin for colors
            const skin = playerSkins.find(sk => sk.id === currentSkin) || playerSkins[0];

            // Ship body gradient based on skin
            let bodyColor1, bodyColor2, wingColor;
            if (skin.id === 'rainbow') {
                const time = Date.now() / 500;
                const hue1 = (time * 50) % 360;
                bodyColor1 = `hsl(${hue1}, 100%, 50%)`;
                bodyColor2 = `hsl(${(hue1 + 60) % 360}, 100%, 40%)`;
                wingColor = `hsl(${(hue1 + 120) % 360}, 100%, 45%)`;
            } else {
                bodyColor1 = skin.bodyColor1;
                bodyColor2 = skin.bodyColor2;
                wingColor = skin.bodyColor2;
            }

            // Ship body (rocket/spacecraft shape)
            ctx.fillStyle = bodyColor1;
            ctx.beginPath();
            ctx.moveTo(25, 0); // Nose
            ctx.lineTo(-15, -15); // Top back
            ctx.lineTo(-10, 0); // Back center
            ctx.lineTo(-15, 15); // Bottom back
            ctx.closePath();
            ctx.fill();

            // Cockpit window (uses eye color)
            ctx.fillStyle = skin.eyeColor;
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(0, -8);
            ctx.lineTo(-5, 0);
            ctx.lineTo(0, 8);
            ctx.closePath();
            ctx.fill();

            // Engine glow
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(-10, -8);
            ctx.lineTo(-25, 0);
            ctx.lineTo(-10, 8);
            ctx.closePath();
            ctx.fill();

            // Inner engine
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(-10, -4);
            ctx.lineTo(-18, 0);
            ctx.lineTo(-10, 4);
            ctx.closePath();
            ctx.fill();

            // Wing top (uses skin secondary color)
            ctx.fillStyle = wingColor;
            ctx.beginPath();
            ctx.moveTo(-5, -10);
            ctx.lineTo(-15, -22);
            ctx.lineTo(-18, -18);
            ctx.lineTo(-12, -10);
            ctx.closePath();
            ctx.fill();

            // Wing bottom
            ctx.beginPath();
            ctx.moveTo(-5, 10);
            ctx.lineTo(-15, 22);
            ctx.lineTo(-18, 18);
            ctx.lineTo(-12, 10);
            ctx.closePath();
            ctx.fill();
        }

        function drawAircraft() {
            // Aircraft body (sleek triangle shape)
            ctx.fillStyle = '#8e44ad';
            ctx.beginPath();
            ctx.moveTo(30, 0); // Nose
            ctx.lineTo(-20, -18); // Top back
            ctx.lineTo(-10, 0); // Back center
            ctx.lineTo(-20, 18); // Bottom back
            ctx.closePath();
            ctx.fill();

            // Aircraft cockpit window
            ctx.fillStyle = '#00d4ff';
            ctx.beginPath();
            ctx.moveTo(20, 0);
            ctx.lineTo(5, -8);
            ctx.lineTo(0, 0);
            ctx.lineTo(5, 8);
            ctx.closePath();
            ctx.fill();

            // Wing top
            ctx.fillStyle = '#9b59b6';
            ctx.beginPath();
            ctx.moveTo(-5, -8);
            ctx.lineTo(-15, -30);
            ctx.lineTo(-20, -28);
            ctx.lineTo(-15, -8);
            ctx.closePath();
            ctx.fill();

            // Wing bottom
            ctx.beginPath();
            ctx.moveTo(-5, 8);
            ctx.lineTo(-15, 30);
            ctx.lineTo(-20, 28);
            ctx.lineTo(-15, 8);
            ctx.closePath();
            ctx.fill();

            // Tail fin
            ctx.fillStyle = '#8e44ad';
            ctx.beginPath();
            ctx.moveTo(-15, 0);
            ctx.lineTo(-25, -12);
            ctx.lineTo(-22, 0);
            ctx.lineTo(-25, 12);
            ctx.closePath();
            ctx.fill();

            // Engine glow
            ctx.fillStyle = '#ff8800';
            ctx.beginPath();
            ctx.moveTo(-20, -5);
            ctx.lineTo(-35, 0);
            ctx.lineTo(-20, 5);
            ctx.closePath();
            ctx.fill();

            // Inner engine glow
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.moveTo(-20, -3);
            ctx.lineTo(-28, 0);
            ctx.lineTo(-20, 3);
            ctx.closePath();
            ctx.fill();

            // Player icon inside cockpit (small square)
            ctx.fillStyle = player.color;
            ctx.fillRect(2, -5, 10, 10);
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(4, -3, 6, 6);
            // Tiny eye
            ctx.fillStyle = '#fff';
            ctx.fillRect(6, -2, 3, 3);
        }

        function drawNormalPlayer() {
            const s = player.width / 2;

            // Get current skin
            const skin = playerSkins.find(sk => sk.id === currentSkin) || playerSkins[0];

            // Glow effect based on skin
            ctx.shadowColor = skin.eyeColor;
            ctx.shadowBlur = 15;

            // Dark outline/border
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.roundRect(-s - 2, -s - 2, player.width + 4, player.height + 4, 6);
            ctx.fill();

            // Body gradient based on skin
            const bodyGradient = ctx.createLinearGradient(-s, -s, -s, s);
            if (skin.id === 'rainbow') {
                // Special rainbow effect
                const time = Date.now() / 500;
                const hue1 = (time * 50) % 360;
                const hue2 = (hue1 + 180) % 360;
                bodyGradient.addColorStop(0, `hsl(${hue1}, 100%, 50%)`);
                bodyGradient.addColorStop(0.5, `hsl(${(hue1 + 90) % 360}, 100%, 50%)`);
                bodyGradient.addColorStop(1, `hsl(${hue2}, 100%, 50%)`);
            } else {
                bodyGradient.addColorStop(0, skin.bodyColor1);
                bodyGradient.addColorStop(0.3, skin.bodyColor1);
                bodyGradient.addColorStop(0.7, skin.bodyColor2);
                bodyGradient.addColorStop(1, skin.bodyColor2);
            }
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.roundRect(-s, -s, player.width, player.height, 4);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Dark face background (mouth area outline)
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 3;

            // Left eye
            ctx.fillStyle = skin.eyeColor;
            ctx.fillRect(-s + 8, -s + 10, 10, 10);
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 2;
            ctx.strokeRect(-s + 8, -s + 10, 10, 10);

            // Right eye
            ctx.fillStyle = skin.eyeColor;
            ctx.fillRect(s - 18, -s + 10, 10, 10);
            ctx.strokeRect(s - 18, -s + 10, 10, 10);

            // Mouth
            ctx.fillStyle = skin.eyeColor;
            ctx.fillRect(-s + 8, s - 16, player.width - 16, 8);
            ctx.strokeRect(-s + 8, s - 16, player.width - 16, 8);
        }

        function drawObstacle(obstacle) {
            const x = obstacle.x;
            const y = obstacle.y;
            const w = obstacle.width;
            const h = obstacle.height;

            if (obstacle.type === 'spike') {
                // Blue glow effect
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 15;

                // Main triangle with gradient (black at bottom to white at top)
                const spikeGradient = ctx.createLinearGradient(x, y + h, x, y);
                spikeGradient.addColorStop(0, '#000000');
                spikeGradient.addColorStop(0.4, '#333333');
                spikeGradient.addColorStop(0.7, '#888888');
                spikeGradient.addColorStop(1, '#ffffff');
                ctx.fillStyle = spikeGradient;
                ctx.beginPath();
                ctx.moveTo(x, y + h);
                ctx.lineTo(x + w / 2, y);
                ctx.lineTo(x + w, y + h);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

                // White outline
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y + h);
                ctx.lineTo(x + w / 2, y);
                ctx.lineTo(x + w, y + h);
                ctx.closePath();
                ctx.stroke();

            } else if (obstacle.type === 'spikeDown') {
                // Upside down spike
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w / 2, y + h);
                ctx.lineTo(x + w, y);
                ctx.closePath();
                ctx.fill();

                // Inner triangle detail
                ctx.fillStyle = '#cc5555';
                ctx.beginPath();
                ctx.moveTo(x + w * 0.25, y);
                ctx.lineTo(x + w / 2, y + h * 0.6);
                ctx.lineTo(x + w * 0.75, y);
                ctx.closePath();
                ctx.fill();

            } else if (obstacle.type === 'longSpike') {
                // Tall/long spike
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.moveTo(x, y + h);
                ctx.lineTo(x + w / 2, y);
                ctx.lineTo(x + w, y + h);
                ctx.closePath();
                ctx.fill();

                // Inner detail - multiple lines going up
                ctx.fillStyle = '#cc5555';
                ctx.beginPath();
                ctx.moveTo(x + w * 0.3, y + h);
                ctx.lineTo(x + w / 2, y + h * 0.2);
                ctx.lineTo(x + w * 0.7, y + h);
                ctx.closePath();
                ctx.fill();

                // Highlight edge
                ctx.strokeStyle = '#ff8888';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + 2, y + h - 2);
                ctx.lineTo(x + w / 2, y + 2);
                ctx.stroke();

            } else if (obstacle.type === 'ceilingBlock') {
                // Block hanging from ceiling
                ctx.fillStyle = '#4a4a6a';
                ctx.fillRect(x, y, w, h);

                // Border
                ctx.strokeStyle = '#6a6a8a';
                ctx.lineWidth = 2;
                ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

                // Inner pattern - vertical lines
                ctx.strokeStyle = '#3a3a5a';
                ctx.lineWidth = 1;
                for (let ly = y + 20; ly < y + h - 10; ly += 25) {
                    ctx.beginPath();
                    ctx.moveTo(x + 8, ly);
                    ctx.lineTo(x + w - 8, ly);
                    ctx.stroke();
                }

            } else if (obstacle.type === 'sawBlade') {
                // Spinning saw blade
                const cx = x + w / 2;
                const cy = y + h / 2;
                const radius = w / 2;

                // Update rotation
                obstacle.rotation = (obstacle.rotation || 0) + 0.15;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(obstacle.rotation);

                // Outer circle
                ctx.fillStyle = '#888';
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();

                // Teeth
                ctx.fillStyle = '#ff4444';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * radius * 0.5, Math.sin(angle) * radius * 0.5);
                    ctx.lineTo(Math.cos(angle - 0.2) * radius * 1.1, Math.sin(angle - 0.2) * radius * 1.1);
                    ctx.lineTo(Math.cos(angle + 0.2) * radius * 1.1, Math.sin(angle + 0.2) * radius * 1.1);
                    ctx.closePath();
                    ctx.fill();
                }

                // Center
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

            } else if (obstacle.type === 'box') {
                // Glow effect
                ctx.shadowColor = '#f39c12';
                ctx.shadowBlur = 15;

                // Box body with gradient
                const boxGradient = ctx.createLinearGradient(x, y, x, y + h);
                boxGradient.addColorStop(0, '#f5a623');
                boxGradient.addColorStop(0.5, '#f39c12');
                boxGradient.addColorStop(1, '#d68910');
                ctx.fillStyle = boxGradient;
                ctx.fillRect(x, y, w, h);
                ctx.shadowBlur = 0;

                // 3D edge highlight (left and top)
                ctx.fillStyle = '#ffc04d';
                ctx.fillRect(x, y, 3, h);
                ctx.fillRect(x, y, w, 3);

                // 3D edge shadow (right and bottom)
                ctx.fillStyle = '#a67c00';
                ctx.fillRect(x + w - 3, y, 3, h);
                ctx.fillRect(x, y + h - 3, w, 3);

                // Top surface (green - safe to land) with glow
                ctx.shadowColor = '#27ae60';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(x, y, w, 8);
                ctx.shadowBlur = 0;

                // Green chevron pattern on top
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.moveTo(x, y + 8);
                ctx.lineTo(x + w / 2, y + 3);
                ctx.lineTo(x + w, y + 8);
                ctx.closePath();
                ctx.fill();

                // Inner darker area with gradient
                const innerGradient = ctx.createRadialGradient(x + w / 2, y + h / 2, 0, x + w / 2, y + h / 2, w / 2);
                innerGradient.addColorStop(0, '#2a2a4e');
                innerGradient.addColorStop(1, '#1a1a2e');
                ctx.fillStyle = innerGradient;
                ctx.fillRect(x + 6, y + 14, w - 12, h - 20);

                // Diamond pattern inside with glow
                ctx.shadowColor = '#f39c12';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#f39c12';
                const cx = x + w / 2;
                const cy = y + h / 2 + 4;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-8, -8, 16, 16);
                ctx.restore();
                ctx.shadowBlur = 0;

                // Smaller inner diamond
                ctx.fillStyle = '#1a1a2e';
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-4, -4, 8, 8);
                ctx.restore();

            } else if (obstacle.type === 'step') {
                // Glow effect
                ctx.shadowColor = '#9b59b6';
                ctx.shadowBlur = 12;

                // Step body with gradient (purple/blue)
                const stepGradient = ctx.createLinearGradient(x, y, x, y + h);
                stepGradient.addColorStop(0, '#a855f7');
                stepGradient.addColorStop(0.5, '#9b59b6');
                stepGradient.addColorStop(1, '#7c3aed');
                ctx.fillStyle = stepGradient;
                ctx.fillRect(x, y, w, h);
                ctx.shadowBlur = 0;

                // 3D edge highlight
                ctx.fillStyle = '#c084fc';
                ctx.fillRect(x, y, 3, h);
                ctx.fillRect(x, y, w, 3);

                // 3D edge shadow
                ctx.fillStyle = '#6b21a8';
                ctx.fillRect(x + w - 3, y, 3, h);
                ctx.fillRect(x, y + h - 3, w, 3);

                // Top surface (cyan - safe to land) with glow
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 12;
                ctx.fillStyle = '#00d4ff';
                ctx.fillRect(x, y, w, 6);
                ctx.shadowBlur = 0;

                // Border
                ctx.strokeStyle = '#8e44ad';
                ctx.lineWidth = 2;
                ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

                // Inner darker area with gradient
                const innerStepGradient = ctx.createRadialGradient(x + w / 2, y + h / 2, 0, x + w / 2, y + h / 2, w / 2);
                innerStepGradient.addColorStop(0, '#2a2a4e');
                innerStepGradient.addColorStop(1, '#1a1a2e');
                ctx.fillStyle = innerStepGradient;
                ctx.fillRect(x + 6, y + 10, w - 12, h - 16);

                // Horizontal lines pattern with glow
                ctx.shadowColor = '#9b59b6';
                ctx.shadowBlur = 4;
                ctx.strokeStyle = '#9b59b6';
                ctx.lineWidth = 2;
                for (let ly = y + 18; ly < y + h - 6; ly += 12) {
                    ctx.beginPath();
                    ctx.moveTo(x + 8, ly);
                    ctx.lineTo(x + w - 8, ly);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;

                // Small triangle accent at top with glow
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#00d4ff';
                ctx.beginPath();
                ctx.moveTo(x + w / 2 - 8, y + 6);
                ctx.lineTo(x + w / 2, y + 2);
                ctx.lineTo(x + w / 2 + 8, y + 6);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

            } else {
                // Deadly block with black top fading to clear, white border, blue glow

                // Blue glow effect
                ctx.shadowColor = '#00d4ff';
                ctx.shadowBlur = 20;

                // White outer border
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y, w, h);
                ctx.shadowBlur = 0;

                // Inner area with gradient (black at top fading to transparent/clear at bottom)
                const innerGradient = ctx.createLinearGradient(x, y, x, y + h);
                innerGradient.addColorStop(0, '#000000');
                innerGradient.addColorStop(0.3, '#1a1a1a');
                innerGradient.addColorStop(0.6, '#444444');
                innerGradient.addColorStop(0.85, '#888888');
                innerGradient.addColorStop(1, '#cccccc');
                ctx.fillStyle = innerGradient;
                ctx.fillRect(x + 3, y + 3, w - 6, h - 6);

                // Subtle inner white border highlight
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x + 4, y + 4, w - 8, h - 8);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            startScreen.style.display = 'none';
            document.getElementById('homePage').style.display = 'none';
            gameRunning = true;
            resetGame();

            // Start generated music
            if (!musicPlaying) {
                startMusic();
                musicPlaying = true;
            }
        }

        // Home page functions
        function updateHomePreview() {
            const skin = playerSkins.find(sk => sk.id === currentSkin) || playerSkins[0];
            const preview = document.getElementById('homePlayerPreview');
            preview.style.background = `linear-gradient(180deg, ${skin.bodyColor1}, ${skin.bodyColor2})`;
            preview.style.boxShadow = `0 0 20px ${skin.eyeColor}`;
            document.getElementById('homeGems').textContent = `üíé ${totalGemsEver}`;
        }

        function startFromHome() {
            document.getElementById('homePage').style.display = 'none';
            gameRunning = true;
            resetGame();

            // Start generated music
            if (!musicPlaying) {
                startMusic();
                musicPlaying = true;
            }
        }

        function goToHome() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('homePage').style.display = 'flex';
            updateHomePreview();
            gameRunning = false;
            stopMusic();
        }

        function openSkinShopFromHome() {
            document.getElementById('homePage').style.display = 'none';
            document.getElementById('skinShop').style.display = 'flex';
            document.getElementById('totalGems').textContent = `Total Gems: ${totalGemsEver}`;
            renderSkinGrid();
        }

        // Skin shop functions
        function openSkinShop() {
            startScreen.style.display = 'none';
            document.getElementById('skinShop').style.display = 'flex';
            document.getElementById('totalGems').textContent = `Total Gems: ${totalGemsEver}`;
            renderSkinGrid();
        }

        function closeSkinShop() {
            document.getElementById('skinShop').style.display = 'none';
            document.getElementById('homePage').style.display = 'flex';
            updateHomePreview();
        }

        function renderSkinGrid() {
            const grid = document.getElementById('skinGrid');
            grid.innerHTML = '';

            playerSkins.forEach(skin => {
                const isOwned = unlockedSkins.includes(skin.id);
                const isSelected = currentSkin === skin.id;
                const canAfford = totalGemsEver >= skin.cost;

                const card = document.createElement('div');
                card.className = `skin-card ${isSelected ? 'selected' : ''} ${!isOwned ? 'locked' : ''}`;

                card.innerHTML = `
                    <div class="skin-preview" style="background: linear-gradient(180deg, ${skin.bodyColor1}, ${skin.bodyColor2}); box-shadow: 0 0 10px ${skin.eyeColor};"></div>
                    <div class="skin-name">${skin.name}</div>
                    ${isOwned ?
                        `<div class="skin-owned">${isSelected ? '‚úì EQUIPPED' : 'OWNED'}</div>` :
                        `<div class="skin-cost" style="color: ${canAfford ? '#00ff00' : '#ff4444'};">üíé ${skin.cost}</div>`
                    }
                `;

                card.onclick = () => selectSkin(skin.id);
                grid.appendChild(card);
            });
        }

        function selectSkin(skinId) {
            const skin = playerSkins.find(s => s.id === skinId);
            if (!skin) return;

            if (unlockedSkins.includes(skinId)) {
                // Already owned - equip it
                currentSkin = skinId;
                localStorage.setItem('currentSkin', currentSkin);
                renderSkinGrid();
            } else if (totalGemsEver >= skin.cost) {
                // Can afford - buy it
                totalGemsEver -= skin.cost;
                unlockedSkins.push(skinId);
                currentSkin = skinId;
                localStorage.setItem('totalGemsEver', totalGemsEver);
                localStorage.setItem('unlockedSkins', JSON.stringify(unlockedSkins));
                localStorage.setItem('currentSkin', currentSkin);
                document.getElementById('totalGems').textContent = `Total Gems: ${totalGemsEver}`;
                renderSkinGrid();
            }
        }

        // Load saved skin data
        function loadSkinData() {
            const savedGems = localStorage.getItem('totalGemsEver');
            const savedSkins = localStorage.getItem('unlockedSkins');
            const savedCurrentSkin = localStorage.getItem('currentSkin');

            if (savedGems) totalGemsEver = parseInt(savedGems);
            if (savedSkins) unlockedSkins = JSON.parse(savedSkins);
            if (savedCurrentSkin && unlockedSkins.includes(savedCurrentSkin)) currentSkin = savedCurrentSkin;
        }

        // Call on page load
        loadSkinData();
        updateHomePreview();

        // Generate hype electronic music using Web Audio API
        function startMusic() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Master volume
            const masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);

            // Bass drum pattern
            function playKick(time) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(masterGain);
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(30, time + 0.1);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                osc.start(time);
                osc.stop(time + 0.2);
            }

            // Hi-hat
            function playHiHat(time) {
                const bufferSize = audioCtx.sampleRate * 0.05;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const highpass = audioCtx.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 8000;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                noise.connect(highpass);
                highpass.connect(gain);
                gain.connect(masterGain);
                noise.start(time);
            }

            // Synth lead
            function playSynth(time, freq) {
                const osc = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.value = freq;
                osc2.frequency.value = freq * 1.01;
                osc.connect(gain);
                osc2.connect(gain);
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                gain.connect(masterGain);
                osc.start(time);
                osc2.start(time);
                osc.stop(time + 0.3);
                osc2.stop(time + 0.3);
            }

            // Bass line
            function playBass(time, freq) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start(time);
                osc.stop(time + 0.2);
            }

            const bpm = 140;
            const beatTime = 60 / bpm;
            const melody = [330, 392, 440, 392, 330, 294, 330, 392];
            const bassNotes = [55, 55, 73, 73, 82, 82, 73, 73];

            function scheduleLoop() {
                const now = audioCtx.currentTime;
                for (let bar = 0; bar < 4; bar++) {
                    for (let beat = 0; beat < 8; beat++) {
                        const time = now + (bar * 8 + beat) * beatTime;
                        // Kick on 1 and 3
                        if (beat % 2 === 0) playKick(time);
                        // Hi-hat on every beat
                        playHiHat(time);
                        // Synth melody
                        if (beat % 2 === 0) playSynth(time, melody[beat]);
                        // Bass
                        if (beat % 2 === 0) playBass(time, bassNotes[beat]);
                    }
                }
                // Schedule next loop
                musicLoopTimeout = setTimeout(scheduleLoop, (4 * 8 * beatTime - 0.1) * 1000);
            }
            scheduleLoop();
        }

        function stopMusic() {
            if (musicLoopTimeout) {
                clearTimeout(musicLoopTimeout);
                musicLoopTimeout = null;
            }
            if (audioCtx) {
                audioCtx.close();
                audioCtx = null;
            }
            musicPlaying = false;
        }

        function gameOver() {
            gameRunning = false;
            player.visible = false;  // Hide player on death
            createDeathParticles();

            const finalScore = totalScore + score;

            if (score > bestProgress) {
                bestProgress = score;
            }

            // Update leaderboard on death with the final score
            if (playerGamertag && finalScore > 0) {
                saveScoreToFirebase(finalScore, currentRound);
            }

            finalScoreDisplay.textContent = `Score: ${finalScore} (Round ${currentRound})`;
            highScoreDisplay.textContent = `Best: ${bestProgress}`;

            setTimeout(() => {
                gameOverScreen.style.display = 'flex';
            }, 1500);  // Wait for explosion animation to finish
        }

        // Direct save to Firebase with specific score
        async function saveScoreToFirebase(scoreToSave, roundToSave) {
            try {
                const sanitizedName = playerGamertag.replace(/[.#$[\]]/g, '_');

                // Check if existing score is higher
                const response = await fetch(`${FIREBASE_DB_URL}/leaderboard/${sanitizedName}.json`);
                const existing = await response.json();

                if (!existing || scoreToSave > existing.score) {
                    await fetch(`${FIREBASE_DB_URL}/leaderboard/${sanitizedName}.json`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: playerGamertag,
                            score: scoreToSave,
                            round: roundToSave
                        })
                    });
                    // Reload leaderboard
                    loadLeaderboard();
                }
            } catch (error) {
                console.error('Save score error:', error);
            }
        }

        function winGame() {
            gameRunning = false;
            levelComplete = true;
            createWinParticles();

            totalScore += score;

            // Save to Firebase
            if (playerGamertag && totalScore > 0) {
                saveScoreToFirebase(totalScore, currentRound);
            }

            winScoreDisplay.textContent = `Round ${currentRound} Complete!`;
            winAttemptsDisplay.textContent = `Round Score: ${score} | Total: ${totalScore}`;

            const nextRoundBtn = document.querySelector('#winScreen .btn');
            if (currentRound < MAX_ROUND) {
                nextRoundBtn.textContent = `NEXT ROUND (${currentRound + 1}/${MAX_ROUND})`;
            } else {
                nextRoundBtn.textContent = 'PLAY AGAIN';
            }

            setTimeout(() => {
                winScreen.style.display = 'flex';
            }, 500);
        }

        function restartGame() {
            attempts++;
            attemptsDisplay.textContent = `Attempts: ${attempts}`;
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            resetGame();
            gameRunning = true;
        }

        function nextRound() {
            if (currentRound < MAX_ROUND) {
                currentRound++;
            } else {
                currentRound = 1;
                totalScore = 0;
            }
            attempts = 1;
            attemptsDisplay.textContent = `Attempts: ${attempts}`;
            winScreen.style.display = 'none';
            resetGame();
            updateRoundDisplay();
            gameRunning = true;
        }

        function updateRoundDisplay() {
            roundDisplay.textContent = `Round: ${currentRound}/${MAX_ROUND}`;
        }

        function resetGame() {
            player.x = PLAYER_BASE_X;
            player.y = canvas.height - GROUND_HEIGHT - player.height;
            player.velocityY = 0;
            player.rotation = 0;
            player.onGround = true;
            player.onPlatform = false;
            player.isJumping = false;
            player.visible = true;  // Make player visible again

            shipMode = false;
            shipVelocityY = 0;
            lastClickTime = 0;
            wasJumpPressed = false;
            wormholeTransition = false;
            wormholeProgress = 0;
            wormholePlayerY = 0;
            secretAreaActive = false;
            secretAreaProgress = 0;
            secretAreaFound = false;
            secretEntryX = 0;
            gems = 0;
            document.getElementById('gems').textContent = `Gems: 0`;
            spawnCountdownActive = false;
            spawnCountdown = 0;
            invincible = false;
            invincibleTimer = 0;
            canOrbJump = false;
            currentOrb = null;
            jumpProgress = 0;

            particles = [];
            spawnWaves = [];  // Clear spawn waves
            score = 0;
            groundOffset = 0;
            levelComplete = false;
            distanceTraveled = 0;
            gameSpeed = GAME_SPEED_INITIAL;

            resetSeed();
            levelPatterns = generateRandomLevel();
            generateLevel();

            scoreDisplay.textContent = `Score: ${totalScore}`;

            // Create spawn wave effect
            createSpawnWaves();
        }

        // ========== GLOBAL LEADERBOARD FUNCTIONS (Firebase) ==========

        async function loadLeaderboard() {
            try {
                leaderboardEntries.innerHTML = '<div class="leaderboard-loading">Loading...</div>';
                const response = await fetch(`${FIREBASE_DB_URL}/leaderboard.json`);
                const data = await response.json();

                if (data) {
                    // Firebase returns an object, convert to array
                    leaderboard = Object.values(data);
                } else {
                    leaderboard = [];
                }
                updateLeaderboardDisplay();
            } catch (error) {
                console.error('Load leaderboard error:', error);
                leaderboardEntries.innerHTML = '<div class="leaderboard-loading">Connecting...</div>';
                setTimeout(loadLeaderboard, 3000);
            }
        }

        async function savePlayerScore() {
            try {
                // Use gamertag as key (sanitize for Firebase)
                const sanitizedName = playerGamertag.replace(/[.#$[\]]/g, '_');
                await fetch(`${FIREBASE_DB_URL}/leaderboard/${sanitizedName}.json`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: playerGamertag,
                        score: totalScore,
                        round: currentRound
                    })
                });
            } catch (error) {
                console.error('Save score error:', error);
            }
        }

        function updateLeaderboardDisplay() {
            leaderboardEntries.innerHTML = '';

            if (leaderboard.length === 0) {
                leaderboardEntries.innerHTML = '<div class="leaderboard-loading">No scores yet! Be the first!</div>';
                return;
            }

            const sorted = [...leaderboard].sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return b.round - a.round;
            });

            sorted.slice(0, 10).forEach((entry, index) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                if (entry.name === playerGamertag) {
                    div.classList.add('current-player');
                }
                div.innerHTML = `
                    <span class="leaderboard-rank">${index + 1}.</span>
                    <span class="leaderboard-name">${entry.name}</span>
                    <span class="leaderboard-score">${entry.score}</span>
                    <span class="leaderboard-round">R${entry.round}</span>
                `;
                leaderboardEntries.appendChild(div);
            });

            // Also update home leaderboard
            updateHomeLeaderboard();
        }

        function updateHomeLeaderboard() {
            const homeEntries = document.getElementById('home-leaderboard-entries');
            if (!homeEntries) return;

            homeEntries.innerHTML = '';

            if (leaderboard.length === 0) {
                homeEntries.innerHTML = '<div class="leaderboard-loading">No scores yet! Be the first!</div>';
                return;
            }

            const sorted = [...leaderboard].sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return b.round - a.round;
            });

            sorted.slice(0, 10).forEach((entry, index) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                if (entry.name === playerGamertag) {
                    div.classList.add('current-player');
                }
                div.innerHTML = `
                    <span class="leaderboard-rank">${index + 1}.</span>
                    <span class="leaderboard-name">${entry.name}</span>
                    <span class="leaderboard-score">${entry.score}</span>
                    <span class="leaderboard-round">R${entry.round}</span>
                `;
                homeEntries.appendChild(div);
            });
        }

        // Admin code for infinite gems
        function checkAdminCode(event) {
            if (event.key === 'Enter') {
                const codeInput = document.getElementById('adminCode');
                const code = codeInput.value;

                if (code === 'ZIZHAN999') {
                    // Admin code accepted - infinite gems!
                    totalGemsEver = 99999;
                    localStorage.setItem('totalGemsEver', totalGemsEver);
                    // Unlock all skins
                    playerSkins.forEach(skin => {
                        if (!unlockedSkins.includes(skin.id)) {
                            unlockedSkins.push(skin.id);
                        }
                    });
                    localStorage.setItem('unlockedSkins', JSON.stringify(unlockedSkins));
                    updateHomePreview();
                    codeInput.value = '';
                    codeInput.placeholder = '‚úì ADMIN ACTIVATED';
                    codeInput.style.borderColor = '#00ff00';
                    codeInput.style.color = '#00ff00';
                } else {
                    codeInput.value = '';
                    codeInput.placeholder = 'Invalid code';
                    codeInput.style.borderColor = '#ff4444';
                }
            }
        }

        async function updatePlayerLeaderboardEntry() {
            try {
                // Get current player's score from Firebase
                const sanitizedName = playerGamertag.replace(/[.#$[\]]/g, '_');
                const response = await fetch(`${FIREBASE_DB_URL}/leaderboard/${sanitizedName}.json`);
                const existing = await response.json();

                // Only update if new score is higher
                if (!existing || totalScore > existing.score) {
                    await savePlayerScore();
                }

                // Reload leaderboard to show updates
                await loadLeaderboard();
            } catch (error) {
                console.error('Update leaderboard error:', error);
            }
        }

        function submitGamertag() {
            const name = gamertagInput.value.trim();
            if (name.length === 0) {
                gamertagInput.style.borderColor = '#ff6b6b';
                gamertagInput.placeholder = 'Enter a name!';
                return;
            }

            playerGamertag = name;
            localStorage.setItem('geometryDashGamertag', playerGamertag);

            gamertagScreen.style.display = 'none';
            leaderboardEl.style.display = 'block';

            currentRound = 1;
            totalScore = 0;
            attempts = 1;

            loadLeaderboard();

            gameRunning = true;
            resetGame();
            updateRoundDisplay();
        }

        gamertagInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                submitGamertag();
            }
        });

        // ========== INITIALIZATION ==========

        function init() {
            const savedGamertag = localStorage.getItem('geometryDashGamertag');

            if (savedGamertag) {
                playerGamertag = savedGamertag;
                gamertagScreen.style.display = 'none';
                startScreen.style.display = 'none';
                leaderboardEl.style.display = 'block';

                loadLeaderboard();

                currentRound = 1;
                totalScore = 0;
                attempts = 1;
                gameRunning = true;
                resetGame();
                updateRoundDisplay();
            } else {
                leaderboardEl.style.display = 'none';
                startScreen.style.display = 'none';
                gamertagScreen.style.display = 'flex';
            }
        }

        // Auto-refresh leaderboard every 5 seconds
        setInterval(loadLeaderboard, 5000);

        init();

        // Start game loop
        gameLoop();
    </script>
</body>

</html>